// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace ShaderSlang.Net.Bindings.Generated
{
    public enum SlangSeverity
    {
        /// <summary>A message that is disabled, filtered out. </summary>
        DISABLED = 0,
        /// <summary>An informative message. </summary>
        NOTE = 1,
        /// <summary>A warning, which indicates a possible problem. </summary>
        WARNING = 2,
        /// <summary>An error, indicating that compilation failed. </summary>
        ERROR = 3,
        /// <summary>An unrecoverable error, which forced compilation to abort. </summary>
        FATAL = 4,
        /// <summary>An internal error, indicating a logic error in the compiler.</summary>
        INTERNAL = 5
    }

    public enum __0 : uint
    {
        VERBOSE_PATHS = 0x1,
        TREAT_WARNINGS_AS_ERRORS = 0x2
    }

    public enum SlangBindableResourceType
    {
        NON_BINDABLE = 0,
        TEXTURE = 1,
        SAMPLER = 2,
        UNIFORM_BUFFER = 3,
        STORAGE_BUFFER = 4
    }

    public enum SlangCompileTarget
    {
        UNKNOWN = 0,
        NONE = 1,
        GLSL = 2,
        GLSL_VULKAN_DEPRECATED = 3,
        GLSL_VULKAN_ONE_DESC_DEPRECATED = 4,
        HLSL = 5,
        SPIRV = 6,
        SPIRV_ASM = 7,
        DXBC = 8,
        DXBC_ASM = 9,
        DXIL = 10,
        DXIL_ASM = 11,
        /// <summary>The C language</summary>
        C_SOURCE = 12,
        /// <summary>C++ code for shader kernels.</summary>
        CPP_SOURCE = 13,
        /// <summary>Standalone binary executable (for hosting CPU/OS)</summary>
        HOST_EXECUTABLE = 14,
        /// <summary>
        /// <para>A shared library/Dll for shader kernels (for hosting</para>
        /// <para>CPU/OS)</para>
        /// </summary>
        SHADER_SHARED_LIBRARY = 15,
        /// <summary>
        /// <para>A CPU target that makes the compiled shader code available</para>
        /// <para>to be run immediately</para>
        /// </summary>
        SHADER_HOST_CALLABLE = 16,
        /// <summary>Cuda source</summary>
        CUDA_SOURCE = 17,
        /// <summary>PTX</summary>
        PTX = 18,
        /// <summary>Object code that contains CUDA functions.</summary>
        CUDA_OBJECT_CODE = 19,
        /// <summary>Object code that can be used for later linking (kernel/shader)</summary>
        OBJECT_CODE = 20,
        /// <summary>C++ code for host library or executable.</summary>
        HOST_CPP_SOURCE = 21,
        /// <summary>Host callable host code (ie non kernel/shader)</summary>
        HOST_HOST_CALLABLE = 22,
        /// <summary>C++ PyTorch binding code.</summary>
        CPP_PYTORCH_BINDING = 23,
        /// <summary>Metal shading language</summary>
        METAL = 24,
        /// <summary>Metal library</summary>
        METAL_LIB = 25,
        /// <summary>Metal library assembly</summary>
        METAL_LIB_ASM = 26,
        /// <summary>A shared library/Dll for host code (for hosting CPU/OS)</summary>
        HOST_SHARED_LIBRARY = 27,
        /// <summary>WebGPU shading language</summary>
        WGSL = 28,
        /// <summary>SPIR-V assembly via WebGPU shading language</summary>
        WGSL_SPIRV_ASM = 29,
        /// <summary>SPIR-V via WebGPU shading language</summary>
        WGSL_SPIRV = 30,
        /// <summary>Bytecode that can be interpreted by the Slang VM</summary>
        HOST_VM = 31,
        /// <summary>C++ header for shader kernels.</summary>
        CPP_HEADER = 32,
        /// <summary>Cuda header</summary>
        CUDA_HEADER = 33,
        /// <summary>Host object code</summary>
        HOST_OBJECT_CODE = 34,
        /// <summary>Host LLVM IR assembly</summary>
        HOST_LLVM_IR = 35,
        /// <summary>Host LLVM IR assembly (kernel/shader)</summary>
        SHADER_LLVM_IR = 36,
        COUNT_OF = 37
    }

    public enum SlangContainerFormat
    {
        NONE = 0,
        SLANG_MODULE = 1
    }

    public enum SlangPassThrough
    {
        NONE = 0,
        FXC = 1,
        DXC = 2,
        GLSLANG = 3,
        SPIRV_DIS = 4,
        /// <summary>Clang C/C++ compiler</summary>
        CLANG = 5,
        /// <summary>Visual studio C/C++ compiler</summary>
        VISUAL_STUDIO = 6,
        /// <summary>GCC C/C++ compiler</summary>
        GCC = 7,
        /// <summary>
        /// <para>Generic C or C++ compiler, which is decided by the</para>
        /// <para>source type</para>
        /// </summary>
        GENERIC_C_CPP = 8,
        /// <summary>NVRTC Cuda compiler</summary>
        NVRTC = 9,
        /// <summary>LLVM 'compiler' - includes LLVM and Clang</summary>
        LLVM = 10,
        /// <summary>SPIRV-opt</summary>
        SPIRV_OPT = 11,
        /// <summary>Metal compiler</summary>
        METAL = 12,
        /// <summary>Tint WGSL compiler</summary>
        TINT = 13,
        /// <summary>SPIRV-link</summary>
        SPIRV_LINK = 14,
        COUNT_OF = 15
    }

    public enum SlangArchiveType
    {
        UNDEFINED = 0,
        ZIP = 1,
        /// <summary>Riff container with no compression</summary>
        RIFF = 2,
        RIFF_DEFLATE = 3,
        RIFF_LZ4 = 4,
        COUNT_OF = 5
    }

    [Flags]
    public enum __1 : uint
    {
        NO_MANGLING = 8,
        NO_CODEGEN = 16,
        OBFUSCATE = 32,
        NO_CHECKING = 0,
        SPLIT_MIXED_TYPES = 0
    }

    [Flags]
    public enum FLAG : uint
    {
        FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES = 16,
        FLAG_GENERATE_WHOLE_PROGRAM = 256,
        FLAG_DUMP_IR = 512,
        FLAG_GENERATE_SPIRV_DIRECTLY = 1024
    }

    public enum SlangFloatingPointMode : uint
    {
        DEFAULT = 0,
        FAST = 1,
        PRECISE = 2
    }

    public enum SlangFpDenormalMode : uint
    {
        ANY = 0,
        PRESERVE = 1,
        FTZ = 2
    }

    public enum SlangLineDirectiveMode : uint
    {
        DEFAULT = 0,
        /// <summary>Don't emit line directives at all. </summary>
        NONE = 1,
        /// <summary>Emit standard C-style `#line` directives. </summary>
        STANDARD = 2,
        /// <summary>
        /// <para>Emit GLSL-style directives with file *number* instead</para>
        /// <para>of name </para>
        /// </summary>
        GLSL = 3,
        /// <summary>
        /// <para>Use a source map to track line mappings (ie no</para>
        /// <para>#line will appear in emitting source) </para>
        /// </summary>
        SOURCE_MAP = 4
    }

    public enum SlangSourceLanguage
    {
        UNKNOWN = 0,
        SLANG = 1,
        HLSL = 2,
        GLSL = 3,
        C = 4,
        CPP = 5,
        CUDA = 6,
        SPIRV = 7,
        METAL = 8,
        WGSL = 9,
        LLVM = 10,
        COUNT_OF = 11
    }

    public enum SlangProfileID : uint
    {
        UNKNOWN = 0
    }

    public enum SlangCapabilityID
    {
        UNKNOWN = 0
    }

    public enum SlangMatrixLayoutMode : uint
    {
        UNKNOWN = 0,
        ROW_MAJOR = 1,
        COLUMN_MAJOR = 2
    }

    public enum SlangStage : uint
    {
        NONE = 0,
        VERTEX = 1,
        HULL = 2,
        DOMAIN = 3,
        GEOMETRY = 4,
        FRAGMENT = 5,
        COMPUTE = 6,
        RAY_GENERATION = 7,
        INTERSECTION = 8,
        ANY_HIT = 9,
        CLOSEST_HIT = 10,
        MISS = 11,
        CALLABLE = 12,
        MESH = 13,
        AMPLIFICATION = 14,
        DISPATCH = 15,
        COUNT = 16,
        PIXEL = 5
    }

    public enum SlangDebugInfoLevel : uint
    {
        /// <summary>Don't emit debug information at all. </summary>
        NONE = 0,
        /// <summary>
        /// <para>Emit as little debug information as possible, while</para>
        /// <para>still supporting stack trackers. </para>
        /// </summary>
        MINIMAL = 1,
        /// <summary>
        /// <para>Emit whatever is the standard level of debug</para>
        /// <para>information for each target. </para>
        /// </summary>
        STANDARD = 2,
        /// <summary>
        /// <para>Emit as much debug information as possible for each</para>
        /// <para>target. </para>
        /// </summary>
        MAXIMAL = 3
    }

    public enum SlangDebugInfoFormat : uint
    {
        /// <summary>Use the default debugging format for the target</summary>
        DEFAULT = 0,
        /// <summary>
        /// <para>CodeView C7 format (typically means debugging information</para>
        /// <para>is embedded in the binary)</para>
        /// </summary>
        C7 = 1,
        /// <summary>Program database</summary>
        PDB = 2,
        /// <summary>Stabs</summary>
        STABS = 3,
        /// <summary>COFF debug info</summary>
        COFF = 4,
        /// <summary>
        /// <para>DWARF debug info (we may want to support specifying the</para>
        /// <para>version)</para>
        /// </summary>
        DWARF = 5,
        COUNT_OF = 6
    }

    public enum SlangOptimizationLevel : uint
    {
        /// <summary>Don't optimize at all. </summary>
        NONE = 0,
        /// <summary>
        /// <para>Default optimization level: balance code quality and</para>
        /// <para>compilation time. </para>
        /// </summary>
        DEFAULT = 1,
        /// <summary>Optimize aggressively. </summary>
        HIGH = 2,
        /// <summary>
        /// <para>Include optimizations that may take a very long time,</para>
        /// <para>or may involve severe space-vs-speed tradeoffs </para>
        /// </summary>
        MAXIMAL = 3
    }

    public enum SlangEmitSpirvMethod : uint
    {
        DEFAULT = 0,
        VIA_GLSL = 1,
        DIRECTLY = 2
    }

    public enum SlangEmitCPUMethod : uint
    {
        DEFAULT = 0,
        VIA_CPP = 1,
        VIA_LLVM = 2
    }

    public enum SlangPathType : uint
    {
        /// <summary>Path specified specifies a directory. </summary>
        DIRECTORY = 0,
        /// <summary>Path specified is to a file. </summary>
        FILE = 1
    }

    public enum OSPathKind : byte
    {
        /// <summary>Paths do not map to the file system</summary>
        None = 0,
        /// <summary>Paths map directly to the file system</summary>
        Direct = 1,
        /// <summary>
        /// <para>Only paths gained via PathKind::OperatingSystem map to the operating</para>
        /// <para>system file system</para>
        /// </summary>
        OperatingSystem = 2
    }

    public enum PathKind
    {
        /// <summary>
        /// <para>Given a path, returns a simplified version of that path.</para>
        /// <para>This typically means removing '..' and/or '.' from the path.</para>
        /// <para>A simplified path must point to the same object as the original.</para>
        /// </summary>
        Simplified = 0,
        /// <summary>
        /// <para>Given a path, returns a 'canonical path' to the item.</para>
        /// <para>This may be the operating system 'canonical path' that is the unique path to the item.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the item exists the returned canonical path should always be usable to access the</para>
        /// <para>item.</para>
        /// <para>If the item the path specifies doesn't exist, the canonical path may not be returnable</para>
        /// <para>or be a path simplification.</para>
        /// <para>Not all file systems support canonical paths.</para>
        /// </remarks>
        Canonical = 1,
        /// <summary>Given a path returns a path such that it is suitable to be displayed to the user.</summary>
        /// <remarks>
        /// <para>For example if the file system is a zip file - it might include the path to the zip</para>
        /// <para>container as well as the path to the specific file.</para>
        /// <para>NOTE! The display path won't necessarily work on the file system to access the item</para>
        /// </remarks>
        Display = 2,
        /// <summary>Get the path to the item on the *operating system* file system, if available.</summary>
        OperatingSystem = 3,
        /// <summary>Get the path to the item on the *operating system* file system, if available.</summary>
        CountOf = 4
    }

    public enum SlangWriterChannel : uint
    {
        DIAGNOSTIC = 0,
        STD_OUTPUT = 1,
        STD_ERROR = 2,
        COUNT_OF = 3
    }

    public enum SlangWriterMode : uint
    {
        TEXT = 0,
        BINARY = 1
    }

    public enum SlangDeclKind : uint
    {
        UNSUPPORTED_FOR_REFLECTION = 0,
        STRUCT = 1,
        FUNC = 2,
        MODULE = 3,
        GENERIC = 4,
        VARIABLE = 5,
        NAMESPACE = 6
    }

    public enum SlangResourceShape : uint
    {
        RESOURCE_BASE_SHAPE_MASK = 0xf,
        RESOURCE_NONE = 0x0,
        TEXTURE_1D = 0x1,
        TEXTURE_2D = 0x2,
        TEXTURE_3D = 0x3,
        TEXTURE_CUBE = 0x4,
        TEXTURE_BUFFER = 0x5,
        STRUCTURED_BUFFER = 0x6,
        BYTE_ADDRESS_BUFFER = 0x7,
        RESOURCE_UNKNOWN = 0x8,
        ACCELERATION_STRUCTURE = 0x9,
        TEXTURE_SUBPASS = 0xa,
        RESOURCE_EXT_SHAPE_MASK = 0x1f0,
        TEXTURE_FEEDBACK_FLAG = 0x10,
        TEXTURE_SHADOW_FLAG = 0x20,
        TEXTURE_ARRAY_FLAG = 0x40,
        TEXTURE_MULTISAMPLE_FLAG = 0x80,
        TEXTURE_COMBINED_FLAG = 0x100,
        TEXTURE_1D_ARRAY = 65,
        TEXTURE_2D_ARRAY = 66,
        TEXTURE_CUBE_ARRAY = 68,
        TEXTURE_2D_MULTISAMPLE = 130,
        TEXTURE_2D_MULTISAMPLE_ARRAY = 194,
        TEXTURE_SUBPASS_MULTISAMPLE = 138
    }

    public enum SlangResourceAccess : uint
    {
        NONE = 0,
        READ = 1,
        READ_WRITE = 2,
        RASTER_ORDERED = 3,
        APPEND = 4,
        CONSUME = 5,
        WRITE = 6,
        FEEDBACK = 7,
        UNKNOWN = 0x7fffffff
    }

    public enum SlangParameterCategory : uint
    {
        NONE = 0,
        MIXED = 1,
        CONSTANT_BUFFER = 2,
        SHADER_RESOURCE = 3,
        UNORDERED_ACCESS = 4,
        VARYING_INPUT = 5,
        VARYING_OUTPUT = 6,
        SAMPLER_STATE = 7,
        UNIFORM = 8,
        DESCRIPTOR_TABLE_SLOT = 9,
        SPECIALIZATION_CONSTANT = 10,
        PUSH_CONSTANT_BUFFER = 11,
        REGISTER_SPACE = 12,
        GENERIC = 13,
        RAY_PAYLOAD = 14,
        HIT_ATTRIBUTES = 15,
        CALLABLE_PAYLOAD = 16,
        SHADER_RECORD = 17,
        EXISTENTIAL_TYPE_PARAM = 18,
        EXISTENTIAL_OBJECT_PARAM = 19,
        SUB_ELEMENT_REGISTER_SPACE = 20,
        SUBPASS = 21,
        METAL_ARGUMENT_BUFFER_ELEMENT = 22,
        METAL_ATTRIBUTE = 23,
        METAL_PAYLOAD = 24,
        COUNT = 25,
        METAL_BUFFER = 2,
        METAL_TEXTURE = 3,
        METAL_SAMPLER = 7,
        VERTEX_INPUT = 5,
        FRAGMENT_OUTPUT = 6,
        COUNT_V1 = 21
    }

    public enum SlangImageFormat : uint
    {
        Unknown = 0,
        Rgba32f = 1,
        Rgba16f = 2,
        Rg32f = 3,
        Rg16f = 4,
        R11fG11fB10f = 5,
        R32f = 6,
        R16f = 7,
        Rgba16 = 8,
        Rgb10A2 = 9,
        Rgba8 = 10,
        Rg16 = 11,
        Rg8 = 12,
        R16 = 13,
        R8 = 14,
        Rgba16Snorm = 15,
        Rgba8Snorm = 16,
        Rg16Snorm = 17,
        Rg8Snorm = 18,
        R16Snorm = 19,
        R8Snorm = 20,
        Rgba32i = 21,
        Rgba16i = 22,
        Rgba8i = 23,
        Rg32i = 24,
        Rg16i = 25,
        Rg8i = 26,
        R32i = 27,
        R16i = 28,
        R8i = 29,
        Rgba32ui = 30,
        Rgba16ui = 31,
        Rgb10A2ui = 32,
        Rgba8ui = 33,
        Rg32ui = 34,
        Rg16ui = 35,
        Rg8ui = 36,
        R32ui = 37,
        R16ui = 38,
        R8ui = 39,
        R64ui = 40,
        R64i = 41,
        Bgra8 = 42
    }

    public enum SlangReflectionGenericArgType : uint
    {
        TYPE = 0,
        INT = 1,
        BOOL = 2
    }

    public enum SlangTypeKind : uint
    {
        NONE = 0,
        STRUCT = 1,
        ARRAY = 2,
        MATRIX = 3,
        VECTOR = 4,
        SCALAR = 5,
        CONSTANT_BUFFER = 6,
        RESOURCE = 7,
        SAMPLER_STATE = 8,
        TEXTURE_BUFFER = 9,
        SHADER_STORAGE_BUFFER = 10,
        PARAMETER_BLOCK = 11,
        GENERIC_TYPE_PARAMETER = 12,
        INTERFACE = 13,
        OUTPUT_STREAM = 14,
        MESH_OUTPUT = 15,
        SPECIALIZED = 16,
        FEEDBACK = 17,
        POINTER = 18,
        DYNAMIC_RESOURCE = 19,
        COUNT = 20
    }

    public enum SlangScalarType : uint
    {
        NONE = 0,
        VOID = 1,
        BOOL = 2,
        INT32 = 3,
        UINT32 = 4,
        INT64 = 5,
        UINT64 = 6,
        FLOAT16 = 7,
        FLOAT32 = 8,
        FLOAT64 = 9,
        INT8 = 10,
        UINT8 = 11,
        INT16 = 12,
        UINT16 = 13,
        INTPTR = 14,
        UINTPTR = 15
    }

    public enum SlangBindingType : uint
    {
        UNKNOWN = 0,
        SAMPLER = 1,
        TEXTURE = 2,
        CONSTANT_BUFFER = 3,
        PARAMETER_BLOCK = 4,
        TYPED_BUFFER = 5,
        RAW_BUFFER = 6,
        COMBINED_TEXTURE_SAMPLER = 7,
        INPUT_RENDER_TARGET = 8,
        INLINE_UNIFORM_DATA = 9,
        RAY_TRACING_ACCELERATION_STRUCTURE = 10,
        VARYING_INPUT = 11,
        VARYING_OUTPUT = 12,
        EXISTENTIAL_VALUE = 13,
        PUSH_CONSTANT = 14,
        MUTABLE_FLAG = 0x100,
        MUTABLE_TETURE = 258,
        MUTABLE_TYPED_BUFFER = 261,
        MUTABLE_RAW_BUFFER = 262,
        BASE_MASK = 0xff,
        EXT_MASK = 0xff00
    }

    public enum SlangLayoutRules : uint
    {
        DEFAULT = 0,
        METAL_ARGUMENT_BUFFER_TIER_2 = 1
    }

    public enum SlangModifierID : uint
    {
        SHARED = 0,
        NO_DIFF = 1,
        STATIC = 2,
        CONST = 3,
        EXPORT = 4,
        EXTERN = 5,
        DIFFERENTIABLE = 6,
        MUTATING = 7,
        IN = 8,
        OUT = 9,
        INOUT = 10
    }

    public enum SlangLanguageVersion : uint
    {
        UNKNOWN = 0,
        LEGACY = 2018,
        _2025 = 2025,
        _2026 = 2026,
        LANGAUGE_VERSION_DEFAULT = 2018,
        LATEST = 2026
    }

    public enum SlangFacility : short
    {
        FACILITY_WIN_GENERAL = 0,
        FACILITY_WIN_INTERFACE = 4,
        FACILITY_WIN_API = 7,
        FACILITY_BASE = 512,
        FACILITY_CORE = 512,
        FACILITY_INTERNAL = 513,
        FACILITY_EXTERNAL_BASE = 528
    }

    /// <remarks>API Reference: slang.h</remarks>
    /// <summary>
    /// <para>Severity of a diagnostic generated by the compiler.</para>
    /// <para>Values come from the enum below, with higher values representing more severe</para>
    /// <para>conditions, and all values &gt;= SLANG_SEVERITY_ERROR indicating compilation</para>
    /// <para>failure.</para>
    /// </summary>
    /// <summary>Flags to control compilation behavior.</summary>
    /// <summary>Flags to control code generation behavior of a compilation target </summary>
    /// <summary>Options to control floating-point precision guarantees for a target.</summary>
    /// <summary>Options to control floating-point denormal handling mode for a target.</summary>
    /// <summary>Options to control emission of `#line` directives</summary>
    /// <summary>A result code for a Slang API operation.</summary>
    /// <remarks>
    /// <para>This type is generally compatible with the Windows API `HRESULT` type. In particular, negative</para>
    /// <para>values indicate failure results, while zero or positive results indicate success.</para>
    /// <para>In general, Slang APIs always return a zero result on success, unless documented otherwise.</para>
    /// <para>Strictly speaking a negative value indicates an error, a positive (or 0) value indicates</para>
    /// <para>success. This can be tested for with the macros SLANG_SUCCEEDED(x) or SLANG_FAILED(x).</para>
    /// <para>It can represent if the call was successful or not. It can also specify in an extensible manner</para>
    /// <para>what facility produced the result (as the integral 'facility') as well as what caused it (as an</para>
    /// <para>integral 'code'). Under the covers SlangResult is represented as a int32_t.</para>
    /// <para>SlangResult is designed to be compatible with COM HRESULT.</para>
    /// <para>It's layout in bits is as follows</para>
    /// <para>Severity | Facility | Code</para>
    /// <para>---------|----------|-----</para>
    /// <para>31       |    30-16 | 15-0</para>
    /// <para>Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number</para>
    /// <para>indicates failure. Facility is where the error originated from. Code is the code specific to the</para>
    /// <para>facility.</para>
    /// <para>Result codes have the following styles,</para>
    /// <para>1) SLANG_name</para>
    /// <para>2) SLANG_s_f_name</para>
    /// <para>3) SLANG_s_name</para>
    /// <para>where s is S for success, E for error</para>
    /// <para>f is the short version of the facility name</para>
    /// <para>Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.</para>
    /// <para>It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique</para>
    /// <para>without it. ie for a facility 'DRIVER' it might make sense to have an error of the form</para>
    /// <para>SLANG_E_DRIVER_OUT_OF_MEMORY</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SlangFuncPtr();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void FileSystemContentsCallBack(global::ShaderSlang.Net.Bindings.Generated.SlangPathType pathType, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr userData);

    /// <summary>An instance of the Slang library.</summary>
    /// <summary>Types of API-managed bindings that a parameter might use.</summary>
    /// <remarks>
    /// <para>`SlangBindingType` represents the distinct types of binding ranges that might be</para>
    /// <para>understood by an underlying graphics API or cross-API abstraction layer.</para>
    /// <para>Several of the enumeration cases here correspond to cases of `VkDescriptorType`</para>
    /// <para>defined by the Vulkan API. Note however that the values of this enumeration</para>
    /// <para>are not the same as those of any particular API.</para>
    /// <para>The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`</para>
    /// <para>because `SlangParameterCategory` differentiates the types of parameters for</para>
    /// <para>the purposes of layout, where the layout rules of some targets will treat</para>
    /// <para>parameters of different types as occupying the same binding space for layout</para>
    /// <para>(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of</para>
    /// <para>`binding` indices, and are not allowed to overlap), while those same types</para>
    /// <para>map to different types of bindings in the API (e.g., both textures and samplers</para>
    /// <para>use different `VkDescriptorType` values).</para>
    /// <para>When you want to answer &quot;what register/binding did this parameter use?&quot; you</para>
    /// <para>should use `SlangParameterCategory`.</para>
    /// <para>When you want to answer &quot;what type of descriptor range should this parameter use?&quot;</para>
    /// <para>you should use `SlangBindingType`.</para>
    /// </remarks>
    /// <summary>Callback type used for diagnostic output.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SlangDiagnosticCallback([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message, __IntPtr userData);

    /// <summary>A request for one or more compilation actions to be performed.</summary>
    public unsafe partial class GUID
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.GUID> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.GUID>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.GUID managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.GUID managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GUID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GUID(native.ToPointer(), skipVTables);
        }

        internal static GUID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GUID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GUID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GUID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GUID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GUID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangProgramLayout
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangProgramLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangProgramLayout(native.ToPointer(), skipVTables);
        }

        internal static SlangProgramLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangProgramLayout)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangProgramLayout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangProgramLayout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangProgramLayout(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangProgramLayout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangEntryPoint
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPoint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPoint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPoint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangEntryPoint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangEntryPoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangEntryPoint(native.ToPointer(), skipVTables);
        }

        internal static SlangEntryPoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangEntryPoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangEntryPoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangEntryPoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangEntryPoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangEntryPoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangEntryPointLayout
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangEntryPointLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangEntryPointLayout(native.ToPointer(), skipVTables);
        }

        internal static SlangEntryPointLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangEntryPointLayout)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangEntryPointLayout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangEntryPointLayout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangEntryPointLayout(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangEntryPointLayout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionDecl
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionDecl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionDecl(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionDecl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionDecl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionDecl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionDecl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionDecl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionDecl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionModifier
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionModifier __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionModifier(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionModifier __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionModifier)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionModifier __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionModifier(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionModifier(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionModifier(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionType
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionType __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionType(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionType __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionType)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionType __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionType(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionType(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionTypeLayout
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionTypeLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionTypeLayout(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionTypeLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionTypeLayout)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionTypeLayout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionTypeLayout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionTypeLayout(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionTypeLayout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionVariable
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionVariable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionVariable(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionVariable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionVariable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionVariable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionVariable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionVariable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionVariable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionVariableLayout
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionVariableLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionVariableLayout(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionVariableLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionVariableLayout)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionVariableLayout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionVariableLayout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionVariableLayout(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionVariableLayout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionTypeParameter
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionTypeParameter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionTypeParameter(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionTypeParameter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionTypeParameter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionTypeParameter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionTypeParameter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionTypeParameter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionTypeParameter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionUserAttribute
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionUserAttribute __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionUserAttribute(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionUserAttribute __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionUserAttribute)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionUserAttribute __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionUserAttribute(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionUserAttribute(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionUserAttribute(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionFunction
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionFunction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionFunction(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionFunction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionFunction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionFunction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionFunction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionFunction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionFunction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SlangReflectionGeneric
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangReflectionGeneric __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangReflectionGeneric(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionGeneric __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangReflectionGeneric)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangReflectionGeneric __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionGeneric(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangReflectionGeneric(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangReflectionGeneric(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>A &quot;Universally Unique Identifier&quot; (UUID)</summary>
    /// <remarks>
    /// <para>The Slang API uses UUIDs to identify interfaces when</para>
    /// <para>using `queryInterface`.</para>
    /// <para>This type is compatible with the `GUID` type defined</para>
    /// <para>by the Component Object Model (COM), but Slang is</para>
    /// <para>not dependent on COM.</para>
    /// </remarks>
    public unsafe partial struct SlangUUID
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint data1;
            internal ushort data2;
            internal ushort data3;
            internal fixed byte data4[8];

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN9SlangUUIDC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        private SlangUUID.__Internal __instance;
        internal ref SlangUUID.__Internal __Instance => ref __instance;

        internal static SlangUUID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SlangUUID(native.ToPointer(), skipVTables);
        }

        internal static SlangUUID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangUUID(native, skipVTables);
        }

        private SlangUUID(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SlangUUID(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ShaderSlang.Net.Bindings.Generated.SlangUUID.__Internal*) native;
        }

        public SlangUUID(global::ShaderSlang.Net.Bindings.Generated.SlangUUID _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public uint Data1
        {
            get
            {
                return __instance.data1;
            }

            set
            {
                __instance.data1 = value;
            }
        }

        public ushort Data2
        {
            get
            {
                return __instance.data2;
            }

            set
            {
                __instance.data2 = value;
            }
        }

        public ushort Data3
        {
            get
            {
                return __instance.data3;
            }

            set
            {
                __instance.data3 = value;
            }
        }

        public Span<byte> Data4
        {
            get
            {
                fixed (byte* __arrPtr = __instance.data4)
                {
                    return new Span<byte>(__arrPtr, 8);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.data4)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 8; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Base interface for components exchanged through the API.</summary>
    /// <remarks>
    /// <para>This interface definition is compatible with the COM `IUnknown`,</para>
    /// <para>and uses the same UUID, but Slang does not require applications</para>
    /// <para>to use or initialize COM.</para>
    /// </remarks>
    [global::System.Runtime.InteropServices.GuidAttribute("00000000-0000-0000-c000-000000000046")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangUnknown : IDisposable
    {
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult QueryInterface();

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        uint AddRef();

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        uint Release();
    }

    [global::System.Runtime.InteropServices.GuidAttribute("87ede0e1-4852-44b0-8bf2-cb31874de239")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangCastable : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        /// <summary>
        /// <para>Can be used to cast to interfaces without reference counting.</para>
        /// <para>Also provides access to internal implementations, when they provide a guid</para>
        /// <para>Can simulate a 'generated' interface as long as kept in scope by cast from.</para>
        /// </summary>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        __IntPtr CastAs(global::ShaderSlang.Net.Bindings.Generated.SlangUUID guid);
    }

    [global::System.Runtime.InteropServices.GuidAttribute("1ec36168-e9f4-430d-bb17-048a8046b31f")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangClonable : global::ShaderSlang.Net.Bindings.Generated.ISlangCastable
    {
        /// <summary>
        /// <para>Note the use of guid is for the desired interface/object.</para>
        /// <para>The object is returned *not* ref counted. Any type that can implements the interface,</para>
        /// <para>derives from ICastable, and so (not withstanding some other issue) will always return</para>
        /// <para>an ICastable interface which other interfaces/types are accessible from via castAs</para>
        /// </summary>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        __IntPtr Clone(global::ShaderSlang.Net.Bindings.Generated.SlangUUID guid);
    }

    /// <summary>A &quot;blob&quot; of binary data.</summary>
    /// <remarks>This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.</remarks>
    [global::System.Runtime.InteropServices.GuidAttribute("8ba5fb08-5195-40e2-ac58-0d989c3a0102")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangBlob : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        __IntPtr GetBufferPointer();

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        ulong GetBufferSize();
    }

    public unsafe partial class SlangTerminatedChars : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal fixed sbyte chars[1];

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN20SlangTerminatedCharsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK20SlangTerminatedCharscvPKcEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OperatorConversion(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN20SlangTerminatedChars11getTypeGuidEv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangUUID.__Internal GetTypeGuid();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangTerminatedChars __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangTerminatedChars(native.ToPointer(), skipVTables);
        }

        internal static SlangTerminatedChars __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangTerminatedChars)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangTerminatedChars __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangTerminatedChars(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangTerminatedChars(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangTerminatedChars(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SlangTerminatedChars()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SlangTerminatedChars(global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator string(global::ShaderSlang.Net.Bindings.Generated.SlangTerminatedChars __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var ___ret = __Internal.OperatorConversion(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public Span<char> Chars
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetCharArray(((__Internal*)__Instance)->chars, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->chars[i] = global::System.Convert.ToSByte(value[i]);
                }
            }
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangUUID TypeGuid
        {
            get
            {
                var ___ret = __Internal.GetTypeGuid();
                return global::ShaderSlang.Net.Bindings.Generated.SlangUUID.__CreateInstance(___ret);
            }
        }
    }

    /// <summary>A (real or virtual) file system.</summary>
    /// <remarks>
    /// <para>Slang can make use of this interface whenever it would otherwise try to load files</para>
    /// <para>from disk, allowing applications to hook and/or override filesystem access from</para>
    /// <para>the compiler.</para>
    /// <para>It is the responsibility of</para>
    /// <para>the caller of any method that returns a ISlangBlob to release the blob when it is no</para>
    /// <para>longer used (using 'release').</para>
    /// </remarks>
    [global::System.Runtime.InteropServices.GuidAttribute("003a09fc-3a4d-4ba0-ad60-1fd863a915ab")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangFileSystem : global::ShaderSlang.Net.Bindings.Generated.ISlangCastable
    {
        /// <summary>Load a file from `path` and return a blob of its contents</summary>
        /// <param name="path">The path to load from, as a null-terminated UTF-8 string.</param>
        /// <param name="outBlob">A destination pointer to receive the blob of the file contents.</param>
        /// <remarks>
        /// <para>A `SlangResult` to indicate success or failure in loading the file.</para>
        /// <para>NOTE! This is a *binary* load - the blob should contain the exact same bytes</para>
        /// <para>as are found in the backing file.</para>
        /// <para>If load is successful, the implementation should create a blob to hold</para>
        /// <para>the file's content, store it to `outBlob`, and return 0.</para>
        /// <para>If the load fails, the implementation should return a failure status</para>
        /// <para>(any negative value will do).</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult LoadFile(string path, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);
    }

    /// <summary>(DEPRECATED) ISlangSharedLibrary</summary>
    [global::System.Runtime.InteropServices.GuidAttribute("9c9d5bc5-eb61-496f-80d7-d147c4a23730")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangSharedLibraryDep1 : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        __IntPtr FindSymbolAddressByName(string name);
    }

    /// <summary>
    /// <para>An interface that can be used to encapsulate access to a shared library. An implementation</para>
    /// <para>does not have to implement the library as a shared library</para>
    /// </summary>
    [global::System.Runtime.InteropServices.GuidAttribute("70dbc7c4-dc3b-4a07-ae7e-752af6a81555")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangSharedLibrary : global::ShaderSlang.Net.Bindings.Generated.ISlangCastable
    {
        /// <summary>Get a function by name. If the library is unloaded will only return nullptr.</summary>
        /// <param name="name">The name of the function</param>
        /// <returns>The function pointer related to the name or nullptr if not found</returns>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.Generated.SlangFuncPtr FindFuncByName(string name);

        /// <summary>Get a symbol by name. If the library is unloaded will only return nullptr.</summary>
        /// <param name="name">The name of the symbol</param>
        /// <returns>The pointer related to the name or nullptr if not found</returns>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        __IntPtr FindSymbolAddressByName(string name);
    }

    [global::System.Runtime.InteropServices.GuidAttribute("6264ab2b-a3e8-4a06-97f1-49bc2d2ab14d")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangSharedLibraryLoader : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        /// <summary>
        /// <para>Load a shared library. In typical usage the library name should *not* contain any</para>
        /// <para>platform specific elements. For example on windows a dll name should *not* be passed with a</para>
        /// <para>'.dll' extension, and similarly on linux a shared library should *not* be passed with the</para>
        /// <para>'lib' prefix and '.so' extension</para>
        /// <para>path The unadorned filename and/or path for the shared library</para>
        /// <para>@param sharedLibraryOut Holds the shared library if successfully loaded </para>
        /// </summary>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult LoadSharedLibrary(string path, global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary sharedLibraryOut);
    }

    /// <summary>An extended file system abstraction.</summary>
    /// <remarks>
    /// <para>Implementing and using this interface over ISlangFileSystem gives much more control over how</para>
    /// <para>paths are managed, as well as how it is determined if two files 'are the same'.</para>
    /// <para>All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.</para>
    /// <para>Blobs that contain strings are always zero terminated.</para>
    /// </remarks>
    [global::System.Runtime.InteropServices.GuidAttribute("5fb632d2-979d-4481-9fee-663c3f1449e1")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangFileSystemExt : global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem
    {
        /// <summary>Get a uniqueIdentity which uniquely identifies an object of the file system.</summary>
        /// <remarks>
        /// <para>Given a path, returns a 'uniqueIdentity' which ideally is the same value for the same object</para>
        /// <para>on the file system.</para>
        /// <para>The uniqueIdentity is used to compare if two paths are the same - which amongst other things</para>
        /// <para>allows Slang to cache source contents internally. It is also used for #pragma once</para>
        /// <para>functionality.</para>
        /// <para>A *requirement* is for any implementation is that two paths can only return the same</para>
        /// <para>uniqueIdentity if the contents of the two files are *identical*. If an implementation breaks</para>
        /// <para>this constraint it can produce incorrect compilation. If an implementation cannot *strictly*</para>
        /// <para>identify *the same* files, this will only have an effect on #pragma once behavior.</para>
        /// <para>The string for the uniqueIdentity is held zero terminated in the ISlangBlob of</para>
        /// <para>outUniqueIdentity.</para>
        /// <para>Note that there are many ways a uniqueIdentity may be generated for a file. For example it</para>
        /// <para>could be the 'canonical path' - assuming it is available and unambiguous for a file system.</para>
        /// <para>Another possible mechanism could be to store the filename combined with the file date time</para>
        /// <para>to uniquely identify it.</para>
        /// <para>The client must ensure the blob be released when no longer used, otherwise memory will leak.</para>
        /// <para>NOTE! Ideally this method would be called 'getPathUniqueIdentity' but for historical reasons</para>
        /// <para>and backward compatibility it's name remains with 'File' even though an implementation</para>
        /// <para>should be made to work with directories too.</para>
        /// <para>A `SlangResult` to indicate success or failure getting the uniqueIdentity.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult GetFileUniqueIdentity(string path, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outUniqueIdentity);

        /// <summary>Calculate a path combining the 'fromPath' with 'path'</summary>
        /// <param name="fromPathType">How to interpret the from path - as a file or a directory.</param>
        /// <param name="fromPath">The from path.</param>
        /// <param name="path">Path to be determined relative to the fromPath</param>
        /// <param name="pathOut">
        /// <para>Holds the string which is the relative path. The string is held in the blob</para>
        /// <para>zero terminated.</para>
        /// </param>
        /// <remarks>
        /// <para>The client must ensure the blob be released when no longer used, otherwise memory will leak.</para>
        /// <para>A `SlangResult` to indicate success or failure in loading the file.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult CalcCombinedPath(global::ShaderSlang.Net.Bindings.Generated.SlangPathType fromPathType, string fromPath, string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob pathOut);

        /// <summary>Gets the type of path that path is on the file system.</summary>
        /// <remarks>
        /// <para>SLANG_OK if located and type is known, else an error. SLANG_E_NOT_FOUND if not</para>
        /// <para>found.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult GetPathType(string path, ref global::ShaderSlang.Net.Bindings.Generated.SlangPathType pathTypeOut);

        /// <summary>Get a path based on the kind.</summary>
        /// <param name="kind">The kind of path wanted</param>
        /// <param name="path">The input path</param>
        /// <param name="outPath">The output path held in a blob</param>
        /// <remarks>
        /// <para>SLANG_OK if successfully simplified the path (SLANG_E_NOT_IMPLEMENTED if not</para>
        /// <para>implemented, or some other error code)</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult GetPath(global::ShaderSlang.Net.Bindings.Generated.PathKind kind, string path, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outPath);

        /// <summary>Clears any cached information </summary>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        void ClearCache();

        /// <summary>Enumerate the contents of the path</summary>
        /// <param name="The">path to enumerate</param>
        /// <param name="callback">This callback is called for each entry in the path.</param>
        /// <param name="userData">This is passed to the callback</param>
        /// <remarks>
        /// <para>Note that for normal Slang operation it isn't necessary to enumerate contents this can</para>
        /// <para>return SLANG_E_NOT_IMPLEMENTED.</para>
        /// <para>SLANG_OK if successful</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult EnumeratePathContents(string path, global::ShaderSlang.Net.Bindings.Generated.FileSystemContentsCallBack callback, __IntPtr userData);

        /// <summary>Returns how paths map to the OS file system</summary>
        /// <remarks>OSPathKind that describes how paths map to the Operating System file system</remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.Generated.OSPathKind GetOSPathKind();
    }

    [global::System.Runtime.InteropServices.GuidAttribute("a058675c-1d65-452a-8458-ccded1427105")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangMutableFileSystem : global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystemExt
    {
        /// <summary>Write data to the specified path.</summary>
        /// <param name="path">The path for data to be saved to</param>
        /// <param name="data">The data to be saved</param>
        /// <param name="size">The size of the data in bytes</param>
        /// <remarks>
        /// <para>SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other</para>
        /// <para>error code)</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult SaveFile(string path, __IntPtr data, ulong size);

        /// <summary>Write data in the form of a blob to the specified path.</summary>
        /// <param name="path">The path for data to be saved to</param>
        /// <param name="dataBlob">The data to be saved</param>
        /// <remarks>
        /// <para>Depending on the implementation writing a blob might be faster/use less memory. It is</para>
        /// <para>assumed the blob is *immutable* and that an implementation can reference count it.</para>
        /// <para>It is not guaranteed loading the same file will return the *same* blob - just a blob with</para>
        /// <para>same contents.</para>
        /// <para>SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other</para>
        /// <para>error code)</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult SaveFileBlob(string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob dataBlob);

        /// <summary>
        /// <para>Remove the entry in the path (directory of file). Will only delete an empty directory,</para>
        /// <para>if not empty will return an error.</para>
        /// </summary>
        /// <param name="path">The path to remove</param>
        /// <remarks>SLANG_OK if successful</remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult Remove(string path);

        /// <summary>Create a directory.</summary>
        /// <param name="path">
        /// <para>To the directory to create. The parent path *must* exist otherwise will return</para>
        /// <para>an error.</para>
        /// </param>
        /// <remarks>
        /// <para>The path to the directory must exist</para>
        /// <para>SLANG_OK if successful</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult CreateDirectory(string path);
    }

    /// <summary>A stream typically of text, used for outputting diagnostic as well as other information.</summary>
    [global::System.Runtime.InteropServices.GuidAttribute("ec457f0e-9add-4e6b-851c-d7fa716d15fd")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangWriter : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        /// <summary>
        /// <para>Begin an append buffer.</para>
        /// <para>NOTE! Only one append buffer can be active at any time.</para>
        /// </summary>
        /// <param name="maxNumChars">The maximum of chars that will be appended</param>
        /// <remarks>The start of the buffer for appending to. </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        char* BeginAppendBuffer(ulong maxNumChars);

        /// <summary>
        /// <para>Ends the append buffer, and is equivalent to a write of the append buffer.</para>
        /// <para>NOTE! That an endAppendBuffer is not necessary if there are no characters to write.</para>
        /// </summary>
        /// <param name="buffer">
        /// <para>is the start of the data to append and must be identical to last value</para>
        /// <para>returned from beginAppendBuffer</para>
        /// </param>
        /// <param name="numChars">
        /// <para>must be a value less than or equal to what was returned from last call to</para>
        /// <para>beginAppendBuffer</para>
        /// </param>
        /// <remarks>Result, will be SLANG_OK on success </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult EndAppendBuffer(char* buffer, ulong numChars);

        /// <summary>Write text to the writer</summary>
        /// <param name="chars">The characters to write out</param>
        /// <param name="numChars">The amount of characters</param>
        /// <remarks>SLANG_OK on success </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult Write(string chars, ulong numChars);

        /// <summary>Flushes any content to the output </summary>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        void Flush();

        /// <summary>Determines if the writer stream is to the console, and can be used to alter the output</summary>
        /// <remarks>Returns true if is a console writer </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        [return: global::System.Runtime.InteropServices.MarshalAsAttribute(global::System.Runtime.InteropServices.UnmanagedType.I1)]
        bool IsConsole();

        /// <summary>Set the mode for the writer to use</summary>
        /// <param name="mode">The mode to use</param>
        /// <remarks>SLANG_OK on success </remarks>
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        global::ShaderSlang.Net.Bindings.SlangResult SetMode(global::ShaderSlang.Net.Bindings.Generated.SlangWriterMode mode);
    }

    [global::System.Runtime.InteropServices.GuidAttribute("197772c7-0155-4b91-84e8-6668baff0619")]
    [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
    public unsafe partial interface ISlangProfiler : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
    {
        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        ulong GetEntryCount();

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        string GetEntryName(uint index);

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        long GetEntryTimeMS(uint index);

        [global::System.Runtime.InteropServices.PreserveSigAttribute()]
        [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
        uint GetEntryInvocationTimes(uint index);
    }

    public unsafe partial struct SlangReflectionGenericArg
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr typeVal;

            [FieldOffset(0)]
            internal long intVal;

            [FieldOffset(0)]
            internal byte boolVal;

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN25SlangReflectionGenericArgC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        private SlangReflectionGenericArg.__Internal __instance;
        internal ref SlangReflectionGenericArg.__Internal __Instance => ref __instance;

        internal static SlangReflectionGenericArg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SlangReflectionGenericArg(native.ToPointer(), skipVTables);
        }

        internal static SlangReflectionGenericArg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangReflectionGenericArg(native, skipVTables);
        }

        private SlangReflectionGenericArg(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SlangReflectionGenericArg(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArg.__Internal*) native;
        }

        public SlangReflectionGenericArg(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArg _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType TypeVal
        {
            get
            {
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(__instance.typeVal, false);
                return __result0;
            }

            set
            {
                __instance.typeVal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public long IntVal
        {
            get
            {
                return __instance.intVal;
            }

            set
            {
                __instance.intVal = value;
            }
        }

        public bool BoolVal
        {
            get
            {
                return __instance.boolVal != 0;
            }

            set
            {
                __instance.boolVal = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class SlangGlobalSessionDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal uint structureSize;
            internal uint apiVersion;
            internal uint minLanguageVersion;
            internal byte enableGLSL;
            internal fixed uint reserved[16];

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN22SlangGlobalSessionDescC2Ev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN22SlangGlobalSessionDescC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SlangGlobalSessionDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SlangGlobalSessionDesc(native.ToPointer(), skipVTables);
        }

        internal static SlangGlobalSessionDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SlangGlobalSessionDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SlangGlobalSessionDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SlangGlobalSessionDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SlangGlobalSessionDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SlangGlobalSessionDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SlangGlobalSessionDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public SlangGlobalSessionDesc(global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Size of this struct.</summary>
        public uint StructureSize
        {
            get
            {
                return ((__Internal*)__Instance)->structureSize;
            }

            set
            {
                ((__Internal*)__Instance)->structureSize = value;
            }
        }

        /// <summary>Slang API version.</summary>
        public uint ApiVersion
        {
            get
            {
                return ((__Internal*)__Instance)->apiVersion;
            }

            set
            {
                ((__Internal*)__Instance)->apiVersion = value;
            }
        }

        /// <summary>Specify the oldest Slang language version that any sessions will use.</summary>
        public uint MinLanguageVersion
        {
            get
            {
                return ((__Internal*)__Instance)->minLanguageVersion;
            }

            set
            {
                ((__Internal*)__Instance)->minLanguageVersion = value;
            }
        }

        /// <summary>Whether to enable GLSL support.</summary>
        public bool EnableGLSL
        {
            get
            {
                return ((__Internal*)__Instance)->enableGLSL != 0;
            }

            set
            {
                ((__Internal*)__Instance)->enableGLSL = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>Reserved for future use.</summary>
        public Span<uint> Reserved
        {
            get
            {
                return new Span<uint>(((__Internal*)__Instance)->reserved, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class slang
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetBuildTagString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetBuildTagString();

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_createBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SlangCreateBlob(__IntPtr data, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_loadModuleFromSource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SlangLoadModuleFromSource(__IntPtr session, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string moduleName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string source, ulong sourceSize, __IntPtr outDiagnostics);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_loadModuleFromIRBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SlangLoadModuleFromIRBlob(__IntPtr session, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string moduleName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, __IntPtr source, ulong sourceSize, __IntPtr outDiagnostics);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_loadModuleInfoFromIRBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangLoadModuleInfoFromIRBlob(__IntPtr session, __IntPtr source, ulong sourceSize, long* outModuleVersion, sbyte** outModuleCompilerVersion, sbyte** outModuleName);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_createGlobalSession", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSession(long apiVersion, __IntPtr outGlobalSession);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_createGlobalSession2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSession2(__IntPtr desc, __IntPtr outGlobalSession);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_createGlobalSessionWithoutCoreModule", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSessionWithoutCoreModule(long apiVersion, __IntPtr outGlobalSession);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_Z27slang_getEmbeddedCoreModulev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SlangGetEmbeddedCoreModule();

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SlangShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_getLastInternalErrorMessage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SlangGetLastInternalErrorMessage();

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_createByteCodeRunner", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangCreateByteCodeRunner(__IntPtr desc, __IntPtr outByteCodeRunner);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "slang_disassembleByteCode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SlangDisassembleByteCode(__IntPtr moduleBlob, __IntPtr outDisassemblyBlob);
        }

        /// <summary>
        /// <para>Get the build version 'tag' string. The string is the same as</para>
        /// <para>produced via `git describe --tags --match v*` for the project. If such a</para>
        /// <para>version could not be determined at build time then the contents will be</para>
        /// <para>0.0.0-unknown. Any string can be set by passing</para>
        /// <para>-DSLANG_VERSION_FULL=whatever during the cmake invocation.</para>
        /// </summary>
        /// <returns>The build tag string</returns>
        /// <remarks>
        /// <para>This function will return exactly the same result as the method</para>
        /// <para>getBuildTagString on IGlobalSession.</para>
        /// <para>An advantage of using this function over the method is that doing so does</para>
        /// <para>not require the creation of a session, which can be a fairly costly</para>
        /// <para>operation.</para>
        /// </remarks>
        public static string SpGetBuildTagString()
        {
            var ___ret = __Internal.SpGetBuildTagString();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.ISlangBlob SlangCreateBlob(__IntPtr data, ulong size)
        {
            var ___ret = __Internal.SlangCreateBlob(data, size);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.ISlangBlob.__CreateInstance(___ret) : default;
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.Slang.IModule SlangLoadModuleFromSource(global::ShaderSlang.Net.Bindings.Generated.Slang.ISession session, string moduleName, string path, string source, ulong sourceSize, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToISession;
            var ____arg5 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
            var __arg5 = new __IntPtr(&____arg5);
            var ___ret = __Internal.SlangLoadModuleFromSource(__arg0, moduleName, path, source, sourceSize, __arg5);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.IModule.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>Load a module from IR data.</summary>
        /// <param name="session">The session to load the module into.</param>
        /// <param name="moduleName">Name of the module to load.</param>
        /// <param name="path">Path for the module (used for diagnostics).</param>
        /// <param name="source">IR data containing the module.</param>
        /// <param name="sourceSize">Size of the IR data in bytes.</param>
        /// <param name="outDiagnostics">(out, optional) Diagnostics output.</param>
        /// <returns>The loaded module on success, or nullptr on failure.</returns>
        public static global::ShaderSlang.Net.Bindings.Generated.Slang.IModule SlangLoadModuleFromIRBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ISession session, string moduleName, string path, __IntPtr source, ulong sourceSize, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToISession;
            var ____arg5 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
            var __arg5 = new __IntPtr(&____arg5);
            var ___ret = __Internal.SlangLoadModuleFromIRBlob(__arg0, moduleName, path, source, sourceSize, __arg5);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.IModule.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>Read module info (name and version) from IR data.</summary>
        /// <param name="session">The session to use for loading module info.</param>
        /// <param name="source">IR data containing the module.</param>
        /// <param name="sourceSize">Size of the IR data in bytes.</param>
        /// <param name="outModuleVersion">(out) Module version number.</param>
        /// <param name="outModuleCompilerVersion">(out) Compiler version that created the module.</param>
        /// <param name="outModuleName">(out) Name of the module.</param>
        /// <returns>SLANG_OK on success, or an error code on failure.</returns>
        public static global::ShaderSlang.Net.Bindings.SlangResult SlangLoadModuleInfoFromIRBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ISession session, __IntPtr source, ulong sourceSize, ref long outModuleVersion, string outModuleCompilerVersion, string outModuleName)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToISession;
            fixed (long* __outModuleVersion3 = &outModuleVersion)
            {
                var __arg3 = __outModuleVersion3;
                var __bytes4 = global::System.Text.Encoding.UTF8.GetBytes(outModuleCompilerVersion);
                var __bytePtr4 = Marshal.AllocHGlobal(__bytes4.Length + 1);
                Marshal.Copy(__bytes4, 0, __bytePtr4, __bytes4.Length);
                Marshal.WriteByte(__bytePtr4 + __bytes4.Length, 0);
                var __arg4 = (sbyte*) __bytePtr4;
                var __bytes5 = global::System.Text.Encoding.UTF8.GetBytes(outModuleName);
                var __bytePtr5 = Marshal.AllocHGlobal(__bytes5.Length + 1);
                Marshal.Copy(__bytes5, 0, __bytePtr5, __bytes5.Length);
                Marshal.WriteByte(__bytePtr5 + __bytes5.Length, 0);
                var __arg5 = (sbyte*) __bytePtr5;
                var ___ret = __Internal.SlangLoadModuleInfoFromIRBlob(__arg0, source, sourceSize, __arg3, &__arg4, &__arg5);
                return ___ret;
            }
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSession(long apiVersion, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession outGlobalSession)
        {
            var ____arg1 = outGlobalSession is null ? __IntPtr.Zero : outGlobalSession.__PointerToIGlobalSession;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SlangCreateGlobalSession(apiVersion, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSession2(global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc desc, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession outGlobalSession)
        {
            var __arg0 = desc is null ? __IntPtr.Zero : desc.__Instance;
            var ____arg1 = outGlobalSession is null ? __IntPtr.Zero : outGlobalSession.__PointerToIGlobalSession;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SlangCreateGlobalSession2(__arg0, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SlangCreateGlobalSessionWithoutCoreModule(long apiVersion, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession outGlobalSession)
        {
            var ____arg1 = outGlobalSession is null ? __IntPtr.Zero : outGlobalSession.__PointerToIGlobalSession;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SlangCreateGlobalSessionWithoutCoreModule(apiVersion, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.ISlangBlob SlangGetEmbeddedCoreModule()
        {
            var ___ret = __Internal.SlangGetEmbeddedCoreModule();
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.ISlangBlob.__CreateInstance(___ret) : default;
            return __result0;
        }

        public static void SlangShutdown()
        {
            __Internal.SlangShutdown();
        }

        public static string SlangGetLastInternalErrorMessage()
        {
            var ___ret = __Internal.SlangGetLastInternalErrorMessage();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Create a byte code runner that can execute Slang byte code.</summary>
        public static global::ShaderSlang.Net.Bindings.SlangResult SlangCreateByteCodeRunner(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc desc, global::ShaderSlang.Net.Bindings.Generated.Slang.IByteCodeRunner outByteCodeRunner)
        {
            var __arg0 = desc is null ? __IntPtr.Zero : desc.__Instance;
            var ____arg1 = outByteCodeRunner is null ? __IntPtr.Zero : outByteCodeRunner.__PointerToIByteCodeRunner;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SlangCreateByteCodeRunner(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Disassemble a Slang byte code blob into human-readable text.</summary>
        public static global::ShaderSlang.Net.Bindings.SlangResult SlangDisassembleByteCode(global::ShaderSlang.Net.Bindings.Generated.ISlangBlob moduleBlob, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDisassemblyBlob)
        {
            var __arg0 = moduleBlob is null ? __IntPtr.Zero : moduleBlob.__PointerToISlangBlob;
            var ____arg1 = outDisassemblyBlob is null ? __IntPtr.Zero : outDisassemblyBlob.__PointerToISlangBlob;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SlangDisassembleByteCode(__arg0, __arg1);
            return ___ret;
        }

        public const uint KDefaultTargetFlags = 1024;    }

    namespace Slang
    {
        public enum CompilerOptionName
        {
            MacroDefine = 0,
            DepFile = 1,
            EntryPointName = 2,
            Specialize = 3,
            Help = 4,
            HelpStyle = 5,
            Include = 6,
            Language = 7,
            MatrixLayoutColumn = 8,
            MatrixLayoutRow = 9,
            ZeroInitialize = 10,
            IgnoreCapabilities = 11,
            RestrictiveCapabilityCheck = 12,
            ModuleName = 13,
            Output = 14,
            Profile = 15,
            Stage = 16,
            Target = 17,
            Version = 18,
            WarningsAsErrors = 19,
            DisableWarnings = 20,
            EnableWarning = 21,
            DisableWarning = 22,
            DumpWarningDiagnostics = 23,
            InputFilesRemain = 24,
            EmitIr = 25,
            ReportDownstreamTime = 26,
            ReportPerfBenchmark = 27,
            ReportCheckpointIntermediates = 28,
            SkipSPIRVValidation = 29,
            SourceEmbedStyle = 30,
            SourceEmbedName = 31,
            SourceEmbedLanguage = 32,
            DisableShortCircuit = 33,
            MinimumSlangOptimization = 34,
            DisableNonEssentialValidations = 35,
            DisableSourceMap = 36,
            UnscopedEnum = 37,
            PreserveParameters = 38,
            Capability = 39,
            DefaultImageFormatUnknown = 40,
            DisableDynamicDispatch = 41,
            DisableSpecialization = 42,
            FloatingPointMode = 43,
            DebugInformation = 44,
            LineDirectiveMode = 45,
            Optimization = 46,
            Obfuscate = 47,
            VulkanBindShift = 48,
            VulkanBindGlobals = 49,
            VulkanInvertY = 50,
            VulkanUseDxPositionW = 51,
            VulkanUseEntryPointName = 52,
            VulkanUseGLLayout = 53,
            VulkanEmitReflection = 54,
            GLSLForceScalarLayout = 55,
            EnableEffectAnnotations = 56,
            EmitSpirvViaGLSL = 57,
            EmitSpirvDirectly = 58,
            SPIRVCoreGrammarJSON = 59,
            IncompleteLibrary = 60,
            CompilerPath = 61,
            DefaultDownstreamCompiler = 62,
            DownstreamArgs = 63,
            PassThrough = 64,
            DumpRepro = 65,
            DumpReproOnError = 66,
            ExtractRepro = 67,
            LoadRepro = 68,
            LoadReproDirectory = 69,
            ReproFallbackDirectory = 70,
            DumpAst = 71,
            DumpIntermediatePrefix = 72,
            DumpIntermediates = 73,
            DumpIr = 74,
            DumpIrIds = 75,
            PreprocessorOutput = 76,
            OutputIncludes = 77,
            ReproFileSystem = 78,
            REMOVED_SerialIR = 79,
            SkipCodeGen = 80,
            ValidateIr = 81,
            VerbosePaths = 82,
            VerifyDebugSerialIr = 83,
            NoCodeGen = 84,
            FileSystem = 85,
            Heterogeneous = 86,
            NoMangle = 87,
            NoHLSLBinding = 88,
            NoHLSLPackConstantBufferElements = 89,
            ValidateUniformity = 90,
            AllowGLSL = 91,
            EnableExperimentalPasses = 92,
            BindlessSpaceIndex = 93,
            ArchiveType = 94,
            CompileCoreModule = 95,
            Doc = 96,
            IrCompression = 97,
            LoadCoreModule = 98,
            ReferenceModule = 99,
            SaveCoreModule = 100,
            SaveCoreModuleBinSource = 101,
            TrackLiveness = 102,
            LoopInversion = 103,
            ParameterBlocksUseRegisterSpaces = 104,
            LanguageVersion = 105,
            TypeConformance = 106,
            EnableExperimentalDynamicDispatch = 107,
            EmitReflectionJSON = 108,
            CountOfParsableOptions = 109,
            DebugInformationFormat = 110,
            VulkanBindShiftAll = 111,
            GenerateWholeProgram = 112,
            UseUpToDateBinaryModule = 113,
            EmbedDownstreamIR = 114,
            ForceDXLayout = 115,
            EmitSpirvMethod = 116,
            SaveGLSLModuleBinSource = 117,
            SkipDownstreamLinking = 118,
            DumpModule = 119,
            GetModuleInfo = 120,
            GetSupportedModuleVersions = 121,
            EmitSeparateDebug = 122,
            DenormalModeFp16 = 123,
            DenormalModeFp32 = 124,
            DenormalModeFp64 = 125,
            UseMSVCStyleBitfieldPacking = 126,
            ForceCLayout = 127,
            ExperimentalFeature = 128,
            ReportDetailedPerfBenchmark = 129,
            ValidateIRDetailed = 130,
            DumpIRBefore = 131,
            DumpIRAfter = 132,
            EmitCPUMethod = 133,
            EmitCPUViaCPP = 134,
            EmitCPUViaLLVM = 135,
            LLVMTargetTriple = 136,
            LLVMCPU = 137,
            LLVMFeatures = 138,
            CountOf = 139,
            ReportDynamicDispatchSites = 140
        }

        public enum CompilerOptionValueKind
        {
            Int = 0,
            String = 1
        }

        public enum ParameterCategory : uint
        {
            None = 0,
            Mixed = 1,
            ConstantBuffer = 2,
            ShaderResource = 3,
            UnorderedAccess = 4,
            VaryingInput = 5,
            VaryingOutput = 6,
            SamplerState = 7,
            Uniform = 8,
            DescriptorTableSlot = 9,
            SpecializationConstant = 10,
            PushConstantBuffer = 11,
            RegisterSpace = 12,
            GenericResource = 13,
            RayPayload = 14,
            HitAttributes = 15,
            CallablePayload = 16,
            ShaderRecord = 17,
            ExistentialTypeParam = 18,
            ExistentialObjectParam = 19,
            SubElementRegisterSpace = 20,
            InputAttachmentIndex = 21,
            MetalBuffer = 2,
            MetalTexture = 3,
            MetalArgumentBufferElement = 22,
            MetalAttribute = 23,
            MetalPayload = 24,
            VertexInput = 5,
            FragmentOutput = 6
        }

        public enum BindingType : uint
        {
            Unknown = 0,
            Sampler = 1,
            Texture = 2,
            ConstantBuffer = 3,
            ParameterBlock = 4,
            TypedBuffer = 5,
            RawBuffer = 6,
            CombinedTextureSampler = 7,
            InputRenderTarget = 8,
            InlineUniformData = 9,
            RayTracingAccelerationStructure = 10,
            VaryingInput = 11,
            VaryingOutput = 12,
            ExistentialValue = 13,
            PushConstant = 14,
            MutableFlag = 256,
            MutableTexture = 258,
            MutableTypedBuffer = 261,
            MutableRawBuffer = 262,
            BaseMask = 255,
            ExtMask = 65280
        }

        public enum LayoutRules : uint
        {
            Default = 0,
            MetalArgumentBufferTier2 = 1
        }

        public enum ContainerType
        {
            None = 0,
            UnsizedArray = 1,
            StructuredBuffer = 2,
            ConstantBuffer = 3,
            ParameterBlock = 4
        }

        public enum BuiltinModuleName
        {
            Core = 0,
            GLSL = 1
        }

        public enum KSessionFlagsNone : uint
        {
            kSessionFlagsNone = 0
        }

        public enum OperandDataType
        {
            General = 0,
            Int32 = 1,
            Int64 = 2,
            Float32 = 3,
            Float64 = 4,
            String = 5
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void VMExtFunction(__IntPtr context, __IntPtr inst, __IntPtr userData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void VMPrintFunc([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message, __IntPtr userData);

        public unsafe partial class CompilerOptionValue : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValueKind kind;
                internal int intValue0;
                internal int intValue1;
                internal __IntPtr stringValue0;
                internal __IntPtr stringValue1;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19CompilerOptionValueC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19CompilerOptionValueC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            private bool __stringValue0_OwnsNativeMemory = false;
            private bool __stringValue1_OwnsNativeMemory = false;
            protected bool __ownsNativeInstance;

            internal static CompilerOptionValue __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CompilerOptionValue(native.ToPointer(), skipVTables);
            }

            internal static CompilerOptionValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CompilerOptionValue)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CompilerOptionValue __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CompilerOptionValue(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CompilerOptionValue(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CompilerOptionValue(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public CompilerOptionValue()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public CompilerOptionValue(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal*) _0.__Instance);
                if (_0.__stringValue0_OwnsNativeMemory)
                    this.StringValue0 = _0.StringValue0;
                if (_0.__stringValue1_OwnsNativeMemory)
                    this.StringValue1 = _0.StringValue1;
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__stringValue0_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->stringValue0);
                if (__stringValue1_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->stringValue1);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValueKind Kind
            {
                get
                {
                    return ((__Internal*)__Instance)->kind;
                }

                set
                {
                    ((__Internal*)__Instance)->kind = value;
                }
            }

            public int IntValue0
            {
                get
                {
                    return ((__Internal*)__Instance)->intValue0;
                }

                set
                {
                    ((__Internal*)__Instance)->intValue0 = value;
                }
            }

            public int IntValue1
            {
                get
                {
                    return ((__Internal*)__Instance)->intValue1;
                }

                set
                {
                    ((__Internal*)__Instance)->intValue1 = value;
                }
            }

            public string StringValue0
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->stringValue0);
                }

                set
                {
                    if (__stringValue0_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->stringValue0);
                    __stringValue0_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->stringValue0 = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->stringValue0 = (__IntPtr) __bytePtr0;
                }
            }

            public string StringValue1
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->stringValue1);
                }

                set
                {
                    if (__stringValue1_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->stringValue1);
                    __stringValue1_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->stringValue1 = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->stringValue1 = (__IntPtr) __bytePtr0;
                }
            }
        }

        public unsafe partial class BufferReflection
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.BufferReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.BufferReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.BufferReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.BufferReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BufferReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BufferReflection(native.ToPointer(), skipVTables);
            }

            internal static BufferReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BufferReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BufferReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BufferReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BufferReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BufferReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        public unsafe partial class CompilerOptionEntry : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionName name;
                internal global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal value;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19CompilerOptionEntryC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19CompilerOptionEntryC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static CompilerOptionEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CompilerOptionEntry(native.ToPointer(), skipVTables);
            }

            internal static CompilerOptionEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CompilerOptionEntry)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CompilerOptionEntry __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CompilerOptionEntry(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CompilerOptionEntry(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CompilerOptionEntry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public CompilerOptionEntry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public CompilerOptionEntry(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionName Name
            {
                get
                {
                    return ((__Internal*)__Instance)->name;
                }

                set
                {
                    ((__Internal*)__Instance)->name = value;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue Value
            {
                get
                {
                    return global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->value));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->value = *(global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionValue.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial struct GenericArgReflection
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal __IntPtr typeVal;

                [FieldOffset(0)]
                internal long intVal;

                [FieldOffset(0)]
                internal byte boolVal;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20GenericArgReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            private GenericArgReflection.__Internal __instance;
            internal ref GenericArgReflection.__Internal __Instance => ref __instance;

            internal static GenericArgReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new GenericArgReflection(native.ToPointer(), skipVTables);
            }

            internal static GenericArgReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GenericArgReflection(native, skipVTables);
            }

            private GenericArgReflection(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private GenericArgReflection(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericArgReflection.__Internal*) native;
            }

            public GenericArgReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericArgReflection _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection TypeVal
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(__instance.typeVal, false);
                    return __result0;
                }

                set
                {
                    __instance.typeVal = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public long IntVal
            {
                get
                {
                    return __instance.intVal;
                }

                set
                {
                    __instance.intVal = value;
                }
            }

            public bool BoolVal
            {
                get
                {
                    return __instance.boolVal != 0;
                }

                set
                {
                    __instance.boolVal = (byte) (value ? 1 : 0);
                }
            }
        }

        public unsafe partial class Attribute : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9AttributeC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute15getArgumentTypeEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetArgumentType(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute19getArgumentValueIntEjPi", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult GetArgumentValueInt(__IntPtr __instance, uint index, int* value);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute21getArgumentValueFloatEjPf", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult GetArgumentValueFloat(__IntPtr __instance, uint index, float* value);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute22getArgumentValueStringEjPm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetArgumentValueString(__IntPtr __instance, uint index, ulong* outSize);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang9Attribute16getArgumentCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetArgumentCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Attribute __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Attribute(native.ToPointer(), skipVTables);
            }

            internal static Attribute __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Attribute)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Attribute __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Attribute(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Attribute(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Attribute(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Attribute()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Attribute(global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetArgumentType(uint index)
            {
                var ___ret = __Internal.GetArgumentType(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.SlangResult GetArgumentValueInt(uint index, ref int value)
            {
                fixed (int* __value1 = &value)
                {
                    var __arg1 = __value1;
                    var ___ret = __Internal.GetArgumentValueInt(__Instance, index, __arg1);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.SlangResult GetArgumentValueFloat(uint index, ref float value)
            {
                fixed (float* __value1 = &value)
                {
                    var __arg1 = __value1;
                    var ___ret = __Internal.GetArgumentValueFloat(__Instance, index, __arg1);
                    return ___ret;
                }
            }

            public string GetArgumentValueString(uint index, ref ulong outSize)
            {
                fixed (ulong* __outSize1 = &outSize)
                {
                    var __arg1 = __outSize1;
                    var ___ret = __Internal.GetArgumentValueString(__Instance, index, __arg1);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public uint ArgumentCount
            {
                get
                {
                    var ___ret = __Internal.GetArgumentCount(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class TypeReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection15getFieldByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFieldByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection11unwrapArrayEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr UnwrapArray(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection15getElementCountEP18SlangProgramLayout", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetElementCount(__IntPtr __instance, __IntPtr reflection);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection11getFullNameEPP10ISlangBlob", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult GetFullName(__IntPtr __instance, __IntPtr outNameBlob);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection23getUserAttributeByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUserAttributeByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection19findAttributeByNameEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindAttributeByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection23findUserAttributeByNameEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindUserAttributeByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection20applySpecializationsEPNS_17GenericReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ApplySpecializations(__IntPtr __instance, __IntPtr generic);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection7getKindEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.Kind GetKind(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection13getFieldCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetFieldCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection7isArrayEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArray(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection25getTotalArrayElementCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetTotalArrayElementCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection14getElementTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetElementType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection11getRowCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetRowCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection14getColumnCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetColumnCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection13getScalarTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.ScalarType GetScalarType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection21getResourceResultTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetResourceResultType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection16getResourceShapeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape GetResourceShape(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection17getResourceAccessEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess GetResourceAccess(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection21getUserAttributeCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetUserAttributeCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14TypeReflection19getGenericContainerEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetGenericContainer(__IntPtr __instance);
            }

            public enum Kind
            {
                None = 0,
                Struct = 1,
                Array = 2,
                Matrix = 3,
                Vector = 4,
                Scalar = 5,
                ConstantBuffer = 6,
                Resource = 7,
                SamplerState = 8,
                TextureBuffer = 9,
                ShaderStorageBuffer = 10,
                ParameterBlock = 11,
                GenericTypeParameter = 12,
                Interface = 13,
                OutputStream = 14,
                Specialized = 16,
                Feedback = 17,
                Pointer = 18,
                DynamicResource = 19,
                MeshOutput = 15
            }

            public enum ScalarType : uint
            {
                None = 0,
                Void = 1,
                Bool = 2,
                Int32 = 3,
                UInt32 = 4,
                Int64 = 5,
                UInt64 = 6,
                Float16 = 7,
                Float32 = 8,
                Float64 = 9,
                Int8 = 10,
                UInt8 = 11,
                Int16 = 12,
                UInt16 = 13
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static TypeReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TypeReflection(native.ToPointer(), skipVTables);
            }

            internal static TypeReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TypeReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static TypeReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TypeReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TypeReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TypeReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TypeReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public TypeReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection GetFieldByIndex(uint index)
            {
                var ___ret = __Internal.GetFieldByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection UnwrapArray()
            {
                var ___ret = __Internal.UnwrapArray(__Instance);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Get the number of elements in an array or vector type.</summary>
            /// <remarks>
            /// <para>Only useful if `getKind() == Kind::Array` or `Kind::Vector`.</para>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded-size arrays.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when size depends on unresolved generic parameters or link-time</para>
            /// <para>constants. The `reflection` parameter can help resolve link-time constants if available.</para>
            /// </remarks>
            public ulong GetElementCount(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
            {
                var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
                var ___ret = __Internal.GetElementCount(__Instance, __arg0);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.SlangResult GetFullName(global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outNameBlob)
            {
                var ____arg0 = outNameBlob is null ? __IntPtr.Zero : outNameBlob.__PointerToISlangBlob;
                var __arg0 = new __IntPtr(&____arg0);
                var ___ret = __Internal.GetFullName(__Instance, __arg0);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute GetUserAttributeByIndex(uint index)
            {
                var ___ret = __Internal.GetUserAttributeByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindAttributeByName(string name)
            {
                var ___ret = __Internal.FindAttributeByName(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindUserAttributeByName(string name)
            {
                var ___ret = __Internal.FindUserAttributeByName(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection ApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection generic)
            {
                var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
                var ___ret = __Internal.ApplySpecializations(__Instance, __arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.Kind kind
            {
                get
                {
                    var ___ret = __Internal.GetKind(__Instance);
                    return ___ret;
                }
            }

            public uint FieldCount
            {
                get
                {
                    var ___ret = __Internal.GetFieldCount(__Instance);
                    return ___ret;
                }
            }

            public bool IsArray
            {
                get
                {
                    var ___ret = __Internal.IsArray(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the total number of elements in a multi-dimensional array type.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded-size arrays.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when size depends on unresolved generic parameters or link-time</para>
            /// <para>constants.</para>
            /// </remarks>
            public ulong TotalArrayElementCount
            {
                get
                {
                    var ___ret = __Internal.GetTotalArrayElementCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection ElementType
            {
                get
                {
                    var ___ret = __Internal.GetElementType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.GetRowCount(__Instance);
                    return ___ret;
                }
            }

            public uint ColumnCount
            {
                get
                {
                    var ___ret = __Internal.GetColumnCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.ScalarType scalarType
            {
                get
                {
                    var ___ret = __Internal.GetScalarType(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection ResourceResultType
            {
                get
                {
                    var ___ret = __Internal.GetResourceResultType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape ResourceShape
            {
                get
                {
                    var ___ret = __Internal.GetResourceShape(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess ResourceAccess
            {
                get
                {
                    var ___ret = __Internal.GetResourceAccess(__Instance);
                    return ___ret;
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public uint UserAttributeCount
            {
                get
                {
                    var ___ret = __Internal.GetUserAttributeCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection GenericContainer
            {
                get
                {
                    var ___ret = __Internal.GetGenericContainer(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class TypeLayoutReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7getSizeE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetSize(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection9getStrideE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetStride(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection12getAlignmentE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetAlignment(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7getSizeENS_17ParameterCategoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetSize_1(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection9getStrideENS_17ParameterCategoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetStride_1(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection12getAlignmentENS_17ParameterCategoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetAlignment_1(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection15getFieldByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFieldByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection20findFieldIndexByNameEPKcS2_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long FindFieldIndexByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string nameBegin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string nameEnd);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection11unwrapArrayEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr UnwrapArray(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection15getElementCountEPNS_16ShaderReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetElementCount(__IntPtr __instance, __IntPtr reflection);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection16getElementStrideE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetElementStride(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection18getCategoryByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetCategoryByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection19getBindingRangeTypeEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.BindingType GetBindingRangeType(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection27isBindingRangeSpecializableEl", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsBindingRangeSpecializable(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection27getBindingRangeBindingCountEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetBindingRangeBindingCount(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection26getFieldBindingRangeOffsetEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetFieldBindingRangeOffset(__IntPtr __instance, long fieldIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection29getBindingRangeLeafTypeLayoutEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBindingRangeLeafTypeLayout(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection27getBindingRangeLeafVariableEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBindingRangeLeafVariable(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection26getBindingRangeImageFormatEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat GetBindingRangeImageFormat(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection33getBindingRangeDescriptorSetIndexEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetBindingRangeDescriptorSetIndex(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection40getBindingRangeFirstDescriptorRangeIndexEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetBindingRangeFirstDescriptorRangeIndex(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection35getBindingRangeDescriptorRangeCountEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetBindingRangeDescriptorRangeCount(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection27getDescriptorSetSpaceOffsetEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetDescriptorSetSpaceOffset(__IntPtr __instance, long setIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection36getDescriptorSetDescriptorRangeCountEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetDescriptorSetDescriptorRangeCount(__IntPtr __instance, long setIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection42getDescriptorSetDescriptorRangeIndexOffsetEll", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetDescriptorSetDescriptorRangeIndexOffset(__IntPtr __instance, long setIndex, long rangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection46getDescriptorSetDescriptorRangeDescriptorCountEll", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetDescriptorSetDescriptorRangeDescriptorCount(__IntPtr __instance, long setIndex, long rangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection35getDescriptorSetDescriptorRangeTypeEll", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.BindingType GetDescriptorSetDescriptorRangeType(__IntPtr __instance, long setIndex, long rangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection39getDescriptorSetDescriptorRangeCategoryEll", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetDescriptorSetDescriptorRangeCategory(__IntPtr __instance, long setIndex, long rangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection34getSubObjectRangeBindingRangeIndexEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetSubObjectRangeBindingRangeIndex(__IntPtr __instance, long subObjectRangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection28getSubObjectRangeSpaceOffsetEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetSubObjectRangeSpaceOffset(__IntPtr __instance, long subObjectRangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection23getSubObjectRangeOffsetEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSubObjectRangeOffset(__IntPtr __instance, long subObjectRangeIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7getTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7getKindEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.Kind GetKind(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection13getFieldCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetFieldCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection18getExplicitCounterEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetExplicitCounter(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7isArrayEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArray(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection25getTotalArrayElementCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetTotalArrayElementCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection20getElementTypeLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetElementTypeLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection19getElementVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetElementVarLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection21getContainerVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetContainerVarLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection20getParameterCategoryEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetParameterCategory(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection16getCategoryCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetCategoryCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection11getRowCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetRowCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection14getColumnCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetColumnCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection13getScalarTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.ScalarType GetScalarType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection21getResourceResultTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetResourceResultType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection16getResourceShapeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape GetResourceShape(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection17getResourceAccessEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess GetResourceAccess(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection19getMatrixLayoutModeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode GetMatrixLayoutMode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection20getGenericParamIndexEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetGenericParamIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection24getPendingDataTypeLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPendingDataTypeLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection38getSpecializedTypePendingDataVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSpecializedTypePendingDataVarLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection20getBindingRangeCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetBindingRangeCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection36getExplicitCounterBindingRangeOffsetEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetExplicitCounterBindingRangeOffset(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection21getDescriptorSetCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetDescriptorSetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20TypeLayoutReflection22getSubObjectRangeCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetSubObjectRangeCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static TypeLayoutReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TypeLayoutReflection(native.ToPointer(), skipVTables);
            }

            internal static TypeLayoutReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TypeLayoutReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static TypeLayoutReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TypeLayoutReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TypeLayoutReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TypeLayoutReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TypeLayoutReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public TypeLayoutReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the size of this type layout in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources (e.g., unsized arrays).</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the size depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetSize(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetSize(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the stride of this type layout in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when stride depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetStride(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetStride(__Instance, category);
                return ___ret;
            }

            public int GetAlignment(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetAlignment(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the size of this type layout in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources (e.g., unsized arrays).</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the size depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetSize(global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category)
            {
                var ___ret = __Internal.GetSize_1(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the stride of this type layout in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when stride depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetStride(global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category)
            {
                var ___ret = __Internal.GetStride_1(__Instance, category);
                return ___ret;
            }

            public int GetAlignment(global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category)
            {
                var ___ret = __Internal.GetAlignment_1(__Instance, category);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection GetFieldByIndex(uint index)
            {
                var ___ret = __Internal.GetFieldByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public long FindFieldIndexByName(string nameBegin, string nameEnd)
            {
                var ___ret = __Internal.FindFieldIndexByName(__Instance, nameBegin, nameEnd);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection UnwrapArray()
            {
                var ___ret = __Internal.UnwrapArray(__Instance);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Get the number of elements in an array variable.</summary>
            /// <remarks>
            /// <para>Only useful if `getKind() == Kind::Array`.</para>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded-size arrays.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when size depends on unresolved generic parameters or link-time</para>
            /// <para>constants.</para>
            /// </remarks>
            public ulong GetElementCount(global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection reflection)
            {
                var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
                var ___ret = __Internal.GetElementCount(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Get the stride between elements of an array type layout.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when element stride depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetElementStride(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetElementStride(__Instance, category);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetCategoryByIndex(uint index)
            {
                var ___ret = __Internal.GetCategoryByIndex(__Instance, index);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.BindingType GetBindingRangeType(long index)
            {
                var ___ret = __Internal.GetBindingRangeType(__Instance, index);
                return ___ret;
            }

            public bool IsBindingRangeSpecializable(long index)
            {
                var ___ret = __Internal.IsBindingRangeSpecializable(__Instance, index);
                return ___ret;
            }

            /// <summary>Get the binding count for a binding range at the specified index.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the count depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public long GetBindingRangeBindingCount(long index)
            {
                var ___ret = __Internal.GetBindingRangeBindingCount(__Instance, index);
                return ___ret;
            }

            public long GetFieldBindingRangeOffset(long fieldIndex)
            {
                var ___ret = __Internal.GetFieldBindingRangeOffset(__Instance, fieldIndex);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection GetBindingRangeLeafTypeLayout(long index)
            {
                var ___ret = __Internal.GetBindingRangeLeafTypeLayout(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection GetBindingRangeLeafVariable(long index)
            {
                var ___ret = __Internal.GetBindingRangeLeafVariable(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat GetBindingRangeImageFormat(long index)
            {
                var ___ret = __Internal.GetBindingRangeImageFormat(__Instance, index);
                return ___ret;
            }

            public long GetBindingRangeDescriptorSetIndex(long index)
            {
                var ___ret = __Internal.GetBindingRangeDescriptorSetIndex(__Instance, index);
                return ___ret;
            }

            public long GetBindingRangeFirstDescriptorRangeIndex(long index)
            {
                var ___ret = __Internal.GetBindingRangeFirstDescriptorRangeIndex(__Instance, index);
                return ___ret;
            }

            public long GetBindingRangeDescriptorRangeCount(long index)
            {
                var ___ret = __Internal.GetBindingRangeDescriptorRangeCount(__Instance, index);
                return ___ret;
            }

            public long GetDescriptorSetSpaceOffset(long setIndex)
            {
                var ___ret = __Internal.GetDescriptorSetSpaceOffset(__Instance, setIndex);
                return ___ret;
            }

            public long GetDescriptorSetDescriptorRangeCount(long setIndex)
            {
                var ___ret = __Internal.GetDescriptorSetDescriptorRangeCount(__Instance, setIndex);
                return ___ret;
            }

            /// <summary>Get the index offset for a descriptor range within a descriptor set.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public long GetDescriptorSetDescriptorRangeIndexOffset(long setIndex, long rangeIndex)
            {
                var ___ret = __Internal.GetDescriptorSetDescriptorRangeIndexOffset(__Instance, setIndex, rangeIndex);
                return ___ret;
            }

            /// <summary>Get the descriptor count for a descriptor range within a descriptor set.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the count depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public long GetDescriptorSetDescriptorRangeDescriptorCount(long setIndex, long rangeIndex)
            {
                var ___ret = __Internal.GetDescriptorSetDescriptorRangeDescriptorCount(__Instance, setIndex, rangeIndex);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.BindingType GetDescriptorSetDescriptorRangeType(long setIndex, long rangeIndex)
            {
                var ___ret = __Internal.GetDescriptorSetDescriptorRangeType(__Instance, setIndex, rangeIndex);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetDescriptorSetDescriptorRangeCategory(long setIndex, long rangeIndex)
            {
                var ___ret = __Internal.GetDescriptorSetDescriptorRangeCategory(__Instance, setIndex, rangeIndex);
                return ___ret;
            }

            public long GetSubObjectRangeBindingRangeIndex(long subObjectRangeIndex)
            {
                var ___ret = __Internal.GetSubObjectRangeBindingRangeIndex(__Instance, subObjectRangeIndex);
                return ___ret;
            }

            /// <summary>Get the space offset for a sub-object range.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public long GetSubObjectRangeSpaceOffset(long subObjectRangeIndex)
            {
                var ___ret = __Internal.GetSubObjectRangeSpaceOffset(__Instance, subObjectRangeIndex);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection GetSubObjectRangeOffset(long subObjectRangeIndex)
            {
                var ___ret = __Internal.GetSubObjectRangeOffset(__Instance, subObjectRangeIndex);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection Type
            {
                get
                {
                    var ___ret = __Internal.GetType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.Kind Kind
            {
                get
                {
                    var ___ret = __Internal.GetKind(__Instance);
                    return ___ret;
                }
            }

            public uint FieldCount
            {
                get
                {
                    var ___ret = __Internal.GetFieldCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection ExplicitCounter
            {
                get
                {
                    var ___ret = __Internal.GetExplicitCounter(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public bool IsArray
            {
                get
                {
                    var ___ret = __Internal.IsArray(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the total number of elements in a multi-dimensional array variable.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded-size arrays.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when size depends on unresolved generic parameters or link-time</para>
            /// <para>constants.</para>
            /// </remarks>
            public ulong TotalArrayElementCount
            {
                get
                {
                    var ___ret = __Internal.GetTotalArrayElementCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection ElementTypeLayout
            {
                get
                {
                    var ___ret = __Internal.GetElementTypeLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection ElementVarLayout
            {
                get
                {
                    var ___ret = __Internal.GetElementVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection ContainerVarLayout
            {
                get
                {
                    var ___ret = __Internal.GetContainerVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory ParameterCategory
            {
                get
                {
                    var ___ret = __Internal.GetParameterCategory(__Instance);
                    return ___ret;
                }
            }

            public uint CategoryCount
            {
                get
                {
                    var ___ret = __Internal.GetCategoryCount(__Instance);
                    return ___ret;
                }
            }

            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.GetRowCount(__Instance);
                    return ___ret;
                }
            }

            public uint ColumnCount
            {
                get
                {
                    var ___ret = __Internal.GetColumnCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.ScalarType ScalarType
            {
                get
                {
                    var ___ret = __Internal.GetScalarType(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection ResourceResultType
            {
                get
                {
                    var ___ret = __Internal.GetResourceResultType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape ResourceShape
            {
                get
                {
                    var ___ret = __Internal.GetResourceShape(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess ResourceAccess
            {
                get
                {
                    var ___ret = __Internal.GetResourceAccess(__Instance);
                    return ___ret;
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode MatrixLayoutMode
            {
                get
                {
                    var ___ret = __Internal.GetMatrixLayoutMode(__Instance);
                    return ___ret;
                }
            }

            public int GenericParamIndex
            {
                get
                {
                    var ___ret = __Internal.GetGenericParamIndex(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection PendingDataTypeLayout
            {
                get
                {
                    var ___ret = __Internal.GetPendingDataTypeLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection SpecializedTypePendingDataVarLayout
            {
                get
                {
                    var ___ret = __Internal.GetSpecializedTypePendingDataVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public long BindingRangeCount
            {
                get
                {
                    var ___ret = __Internal.GetBindingRangeCount(__Instance);
                    return ___ret;
                }
            }

            public long ExplicitCounterBindingRangeOffset
            {
                get
                {
                    var ___ret = __Internal.GetExplicitCounterBindingRangeOffset(__Instance);
                    return ___ret;
                }
            }

            public long DescriptorSetCount
            {
                get
                {
                    var ___ret = __Internal.GetDescriptorSetCount(__Instance);
                    return ___ret;
                }
            }

            public long SubObjectRangeCount
            {
                get
                {
                    var ___ret = __Internal.GetSubObjectRangeCount(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class Modifier : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang8ModifierC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public enum ID : uint
            {
                Shared = 0,
                NoDiff = 1,
                Static = 2,
                Const = 3,
                Export = 4,
                Extern = 5,
                Differentiable = 6,
                Mutating = 7,
                In = 8,
                Out = 9,
                InOut = 10
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Modifier __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Modifier(native.ToPointer(), skipVTables);
            }

            internal static Modifier __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Modifier)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Modifier __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Modifier(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Modifier(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Modifier(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Modifier()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Modifier(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class VariableReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection12findModifierENS_8Modifier2IDE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindModifier(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection23getUserAttributeByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUserAttributeByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection19findAttributeByNameEPNS_14IGlobalSessionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindAttributeByName(__IntPtr __instance, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection23findUserAttributeByNameEPNS_14IGlobalSessionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindUserAttributeByName(__IntPtr __instance, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection18getDefaultValueIntEPl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult GetDefaultValueInt(__IntPtr __instance, long* value);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection20applySpecializationsEPNS_17GenericReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ApplySpecializations(__IntPtr __instance, __IntPtr generic);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection7getTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection21getUserAttributeCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetUserAttributeCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection15hasDefaultValueEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDefaultValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18VariableReflection19getGenericContainerEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetGenericContainer(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static VariableReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VariableReflection(native.ToPointer(), skipVTables);
            }

            internal static VariableReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VariableReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static VariableReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VariableReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VariableReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected VariableReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VariableReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public VariableReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier FindModifier(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id)
            {
                var ___ret = __Internal.FindModifier(__Instance, id);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute GetUserAttributeByIndex(uint index)
            {
                var ___ret = __Internal.GetUserAttributeByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindAttributeByName(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
            {
                var __arg0 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
                var ___ret = __Internal.FindAttributeByName(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindUserAttributeByName(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
            {
                var __arg0 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
                var ___ret = __Internal.FindUserAttributeByName(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.SlangResult GetDefaultValueInt(ref long value)
            {
                fixed (long* __value0 = &value)
                {
                    var __arg0 = __value0;
                    var ___ret = __Internal.GetDefaultValueInt(__Instance, __arg0);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection ApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection generic)
            {
                var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
                var ___ret = __Internal.ApplySpecializations(__Instance, __arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection Type
            {
                get
                {
                    var ___ret = __Internal.GetType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public uint UserAttributeCount
            {
                get
                {
                    var ___ret = __Internal.GetUserAttributeCount(__Instance);
                    return ___ret;
                }
            }

            public bool HasDefaultValue
            {
                get
                {
                    var ___ret = __Internal.HasDefaultValue(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection GenericContainer
            {
                get
                {
                    var ___ret = __Internal.GetGenericContainer(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class VariableLayoutReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection12findModifierENS_8Modifier2IDE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindModifier(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection18getCategoryByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetCategoryByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection9getOffsetE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetOffset(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection9getOffsetENS_17ParameterCategoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetOffset_1(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection15getBindingSpaceEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetBindingSpace(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection15getBindingSpaceE22SlangParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetBindingSpace(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection15getBindingSpaceENS_17ParameterCategoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetBindingSpace_1(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection11getVariableEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVariable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection13getTypeLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection11getCategoryEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetCategory(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection16getCategoryCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetCategoryCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection7getTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection15getBindingIndexEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetBindingIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection14getImageFormatEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat GetImageFormat(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection15getSemanticNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSemanticName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection16getSemanticIndexEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetSemanticIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection8getStageEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangStage GetStage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang24VariableLayoutReflection20getPendingDataLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPendingDataLayout(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static VariableLayoutReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VariableLayoutReflection(native.ToPointer(), skipVTables);
            }

            internal static VariableLayoutReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VariableLayoutReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static VariableLayoutReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VariableLayoutReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VariableLayoutReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected VariableLayoutReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VariableLayoutReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public VariableLayoutReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier FindModifier(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id)
            {
                var ___ret = __Internal.FindModifier(__Instance, id);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory GetCategoryByIndex(uint index)
            {
                var ___ret = __Internal.GetCategoryByIndex(__Instance, index);
                return ___ret;
            }

            /// <summary>Get the offset of this variable in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetOffset(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetOffset(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the offset of this variable in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetOffset(global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category)
            {
                var ___ret = __Internal.GetOffset_1(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the binding space for this variable layout.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the space depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public uint GetBindingSpace()
            {
                var ___ret = __Internal.GetBindingSpace(__Instance);
                return ___ret;
            }

            /// <summary>Get the register space/set of this variable in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the space depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetBindingSpace(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
            {
                var ___ret = __Internal.GetBindingSpace(__Instance, category);
                return ___ret;
            }

            /// <summary>Get the register space/set of this variable in the specified parameter category.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the space depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GetBindingSpace(global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory category)
            {
                var ___ret = __Internal.GetBindingSpace_1(__Instance, category);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection Variable
            {
                get
                {
                    var ___ret = __Internal.GetVariable(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection TypeLayout
            {
                get
                {
                    var ___ret = __Internal.GetTypeLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ParameterCategory Category
            {
                get
                {
                    var ___ret = __Internal.GetCategory(__Instance);
                    return ___ret;
                }
            }

            public uint CategoryCount
            {
                get
                {
                    var ___ret = __Internal.GetCategoryCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection Type
            {
                get
                {
                    var ___ret = __Internal.GetType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the binding index for this variable layout.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the index depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public uint BindingIndex
            {
                get
                {
                    var ___ret = __Internal.GetBindingIndex(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat ImageFormat
            {
                get
                {
                    var ___ret = __Internal.GetImageFormat(__Instance);
                    return ___ret;
                }
            }

            public string SemanticName
            {
                get
                {
                    var ___ret = __Internal.GetSemanticName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public ulong SemanticIndex
            {
                get
                {
                    var ___ret = __Internal.GetSemanticIndex(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangStage Stage
            {
                get
                {
                    var ___ret = __Internal.GetStage(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection PendingDataLayout
            {
                get
                {
                    var ___ret = __Internal.GetPendingDataLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class FunctionReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection19getParameterByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParameterByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection23getUserAttributeByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetUserAttributeByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection19findAttributeByNameEPNS_14IGlobalSessionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindAttributeByName(__IntPtr __instance, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection23findUserAttributeByNameEPNS_14IGlobalSessionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindUserAttributeByName(__IntPtr __instance, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection12findModifierENS_8Modifier2IDE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindModifier(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection20applySpecializationsEPNS_17GenericReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ApplySpecializations(__IntPtr __instance, __IntPtr generic);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection22specializeWithArgTypesEjPKPNS_14TypeReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SpecializeWithArgTypes(__IntPtr __instance, uint argCount, __IntPtr types);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection11getOverloadEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetOverload(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection13getReturnTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetReturnType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection17getParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection21getUserAttributeCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetUserAttributeCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection19getGenericContainerEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetGenericContainer(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection12isOverloadedEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOverloaded(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18FunctionReflection16getOverloadCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetOverloadCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static FunctionReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new FunctionReflection(native.ToPointer(), skipVTables);
            }

            internal static FunctionReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (FunctionReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static FunctionReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FunctionReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FunctionReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected FunctionReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public FunctionReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public FunctionReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection GetParameterByIndex(uint index)
            {
                var ___ret = __Internal.GetParameterByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute GetUserAttributeByIndex(uint index)
            {
                var ___ret = __Internal.GetUserAttributeByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindAttributeByName(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
            {
                var __arg0 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
                var ___ret = __Internal.FindAttributeByName(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute FindUserAttributeByName(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
            {
                var __arg0 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
                var ___ret = __Internal.FindUserAttributeByName(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Attribute.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier FindModifier(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id)
            {
                var ___ret = __Internal.FindModifier(__Instance, id);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection ApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection generic)
            {
                var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
                var ___ret = __Internal.ApplySpecializations(__Instance, __arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection SpecializeWithArgTypes(uint argCount, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection types)
            {
                var ____arg1 = types is null ? __IntPtr.Zero : types.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.SpecializeWithArgTypes(__Instance, argCount, __arg1);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection GetOverload(uint index)
            {
                var ___ret = __Internal.GetOverload(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection ReturnType
            {
                get
                {
                    var ___ret = __Internal.GetReturnType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public uint ParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetParameterCount(__Instance);
                    return ___ret;
                }
            }

            public uint UserAttributeCount
            {
                get
                {
                    var ___ret = __Internal.GetUserAttributeCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection GenericContainer
            {
                get
                {
                    var ___ret = __Internal.GetGenericContainer(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public bool IsOverloaded
            {
                get
                {
                    var ___ret = __Internal.IsOverloaded(__Instance);
                    return ___ret;
                }
            }

            public uint OverloadCount
            {
                get
                {
                    var ___ret = __Internal.GetOverloadCount(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class GenericReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection16getTypeParameterEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeParameter(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection17getValueParameterEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetValueParameter(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection31getTypeParameterConstraintCountEPNS_18VariableReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetTypeParameterConstraintCount(__IntPtr __instance, __IntPtr typeParam);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection30getTypeParameterConstraintTypeEPNS_18VariableReflectionEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeParameterConstraintType(__IntPtr __instance, __IntPtr typeParam, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection15getConcreteTypeEPNS_18VariableReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetConcreteType(__IntPtr __instance, __IntPtr typeParam);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection17getConcreteIntValEPNS_18VariableReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetConcreteIntVal(__IntPtr __instance, __IntPtr valueParam);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection20applySpecializationsEPS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ApplySpecializations(__IntPtr __instance, __IntPtr generic);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection6asDeclEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AsDecl(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection21getTypeParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetTypeParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection22getValueParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetValueParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection12getInnerDeclEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetInnerDecl(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection12getInnerKindEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind GetInnerKind(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17GenericReflection24getOuterGenericContainerEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetOuterGenericContainer(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GenericReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GenericReflection(native.ToPointer(), skipVTables);
            }

            internal static GenericReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GenericReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GenericReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GenericReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GenericReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GenericReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GenericReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public GenericReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection GetTypeParameter(uint index)
            {
                var ___ret = __Internal.GetTypeParameter(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection GetValueParameter(uint index)
            {
                var ___ret = __Internal.GetValueParameter(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public uint GetTypeParameterConstraintCount(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection typeParam)
            {
                var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
                var ___ret = __Internal.GetTypeParameterConstraintCount(__Instance, __arg0);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetTypeParameterConstraintType(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection typeParam, uint index)
            {
                var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
                var ___ret = __Internal.GetTypeParameterConstraintType(__Instance, __arg0, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetConcreteType(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection typeParam)
            {
                var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
                var ___ret = __Internal.GetConcreteType(__Instance, __arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public long GetConcreteIntVal(global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection valueParam)
            {
                var __arg0 = valueParam is null ? __IntPtr.Zero : valueParam.__Instance;
                var ___ret = __Internal.GetConcreteIntVal(__Instance, __arg0);
                return ___ret;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection ApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection generic)
            {
                var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
                var ___ret = __Internal.ApplySpecializations(__Instance, __arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection AsDecl
            {
                get
                {
                    var ___ret = __Internal.AsDecl(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public uint TypeParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetTypeParameterCount(__Instance);
                    return ___ret;
                }
            }

            public uint ValueParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetValueParameterCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection InnerDecl
            {
                get
                {
                    var ___ret = __Internal.GetInnerDecl(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind InnerKind
            {
                get
                {
                    var ___ret = __Internal.GetInnerKind(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection OuterGenericContainer
            {
                get
                {
                    var ___ret = __Internal.GetOuterGenericContainer(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class EntryPointReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection19getParameterByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParameterByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection25getComputeThreadGroupSizeEmPm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetComputeThreadGroupSize(__IntPtr __instance, ulong axisCount, ulong* outSizeAlongAxis);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection18getComputeWaveSizeEPm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetComputeWaveSize(__IntPtr __instance, ulong* outWaveSize);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection15getNameOverrideEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNameOverride(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection17getParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection11getFunctionEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFunction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection8getStageEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangStage GetStage(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection22usesAnySampleRateInputEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool UsesAnySampleRateInput(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection12getVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVarLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection13getTypeLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection18getResultVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetResultVarLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang20EntryPointReflection24hasDefaultConstantBufferEv", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDefaultConstantBuffer(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static EntryPointReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new EntryPointReflection(native.ToPointer(), skipVTables);
            }

            internal static EntryPointReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (EntryPointReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static EntryPointReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EntryPointReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private EntryPointReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected EntryPointReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public EntryPointReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public EntryPointReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection GetParameterByIndex(uint index)
            {
                var ___ret = __Internal.GetParameterByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public void GetComputeThreadGroupSize(ulong axisCount, ref ulong outSizeAlongAxis)
            {
                fixed (ulong* __outSizeAlongAxis1 = &outSizeAlongAxis)
                {
                    var __arg1 = __outSizeAlongAxis1;
                    __Internal.GetComputeThreadGroupSize(__Instance, axisCount, __arg1);
                }
            }

            public void GetComputeWaveSize(ref ulong outWaveSize)
            {
                fixed (ulong* __outWaveSize0 = &outWaveSize)
                {
                    var __arg0 = __outWaveSize0;
                    __Internal.GetComputeWaveSize(__Instance, __arg0);
                }
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public string NameOverride
            {
                get
                {
                    var ___ret = __Internal.GetNameOverride(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public uint ParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetParameterCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection Function
            {
                get
                {
                    var ___ret = __Internal.GetFunction(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.SlangStage Stage
            {
                get
                {
                    var ___ret = __Internal.GetStage(__Instance);
                    return ___ret;
                }
            }

            public bool UsesAnySampleRateInput
            {
                get
                {
                    var ___ret = __Internal.UsesAnySampleRateInput(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection VarLayout
            {
                get
                {
                    var ___ret = __Internal.GetVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection TypeLayout
            {
                get
                {
                    var ___ret = __Internal.GetTypeLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection ResultVarLayout
            {
                get
                {
                    var ___ret = __Internal.GetResultVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public bool HasDefaultConstantBuffer
            {
                get
                {
                    var ___ret = __Internal.HasDefaultConstantBuffer(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class TypeParameterReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang23TypeParameterReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang23TypeParameterReflection20getConstraintByIndexEi", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetConstraintByIndex(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang23TypeParameterReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang23TypeParameterReflection8getIndexEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang23TypeParameterReflection18getConstraintCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetConstraintCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static TypeParameterReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TypeParameterReflection(native.ToPointer(), skipVTables);
            }

            internal static TypeParameterReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TypeParameterReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static TypeParameterReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TypeParameterReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TypeParameterReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TypeParameterReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TypeParameterReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public TypeParameterReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetConstraintByIndex(int index)
            {
                var ___ret = __Internal.GetConstraintByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public uint Index
            {
                get
                {
                    var ___ret = __Internal.GetIndex(__Instance);
                    return ___ret;
                }
            }

            public uint ConstraintCount
            {
                get
                {
                    var ___ret = __Internal.GetConstraintCount(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class ShaderReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection23getTypeParameterByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeParameterByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection17findTypeParameterEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTypeParameter(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection19getParameterByIndexEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParameterByIndex(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection3getEPNS_15ICompileRequestE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Get(__IntPtr request);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection20getEntryPointByIndexEm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetEntryPointByIndex(__IntPtr __instance, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection14findTypeByNameEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindTypeByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection18findFunctionByNameEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindFunctionByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection24findFunctionByNameInTypeEPNS_14TypeReflectionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindFunctionByNameInType(__IntPtr __instance, __IntPtr type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection28tryResolveOverloadedFunctionEjPPNS_18FunctionReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr TryResolveOverloadedFunction(__IntPtr __instance, uint candidateCount, __IntPtr candidates);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection19findVarByNameInTypeEPNS_14TypeReflectionEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindVarByNameInType(__IntPtr __instance, __IntPtr type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection13getTypeLayoutEPNS_14TypeReflectionENS_11LayoutRulesE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetTypeLayout(__IntPtr __instance, __IntPtr type, global::ShaderSlang.Net.Bindings.Generated.Slang.LayoutRules rules);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection20findEntryPointByNameEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindEntryPointByName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection14specializeTypeEPNS_14TypeReflectionElPKS2_PP10ISlangBlob", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SpecializeType(__IntPtr __instance, __IntPtr type, long specializationArgCount, __IntPtr specializationArgs, __IntPtr outDiagnostics);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection17specializeGenericEPNS_17GenericReflectionElPK29SlangReflectionGenericArgTypePKNS_20GenericArgReflectionEPP10ISlangBlob", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SpecializeGeneric(__IntPtr __instance, __IntPtr generic, long specializationArgCount, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType* specializationArgTypes, __IntPtr specializationArgVals, __IntPtr outDiagnostics);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection9isSubTypeEPNS_14TypeReflectionES2_", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSubType(__IntPtr __instance, __IntPtr subType, __IntPtr superType);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK5slang16ShaderReflection15getHashedStringEmPm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetHashedString(__IntPtr __instance, ulong index, ulong* outCount);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection6toJsonEPP10ISlangBlob", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult ToJson(__IntPtr __instance, __IntPtr outBlob);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection17getParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection21getTypeParameterCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetTypeParameterCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection10getSessionEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetSession(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection18getEntryPointCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetEntryPointCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection30getGlobalConstantBufferBindingEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetGlobalConstantBufferBinding(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection27getGlobalConstantBufferSizeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetGlobalConstantBufferSize(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK5slang16ShaderReflection20getHashedStringCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetHashedStringCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection25getGlobalParamsTypeLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetGlobalParamsTypeLayout(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ShaderReflection24getGlobalParamsVarLayoutEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetGlobalParamsVarLayout(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ShaderReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ShaderReflection(native.ToPointer(), skipVTables);
            }

            internal static ShaderReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ShaderReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ShaderReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShaderReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ShaderReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ShaderReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ShaderReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public ShaderReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection GetTypeParameterByIndex(uint index)
            {
                var ___ret = __Internal.GetTypeParameterByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection FindTypeParameter(string name)
            {
                var ___ret = __Internal.FindTypeParameter(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeParameterReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection GetParameterByIndex(uint index)
            {
                var ___ret = __Internal.GetParameterByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection GetEntryPointByIndex(ulong index)
            {
                var ___ret = __Internal.GetEntryPointByIndex(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection FindTypeByName(string name)
            {
                var ___ret = __Internal.FindTypeByName(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection FindFunctionByName(string name)
            {
                var ___ret = __Internal.FindFunctionByName(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection FindFunctionByNameInType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, string name)
            {
                var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
                var ___ret = __Internal.FindFunctionByNameInType(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection TryResolveOverloadedFunction(uint candidateCount, global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection candidates)
            {
                var ____arg1 = candidates is null ? __IntPtr.Zero : candidates.__Instance;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.TryResolveOverloadedFunction(__Instance, candidateCount, __arg1);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection FindVarByNameInType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, string name)
            {
                var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
                var ___ret = __Internal.FindVarByNameInType(__Instance, __arg0, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection GetTypeLayout(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.LayoutRules rules)
            {
                var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
                var ___ret = __Internal.GetTypeLayout(__Instance, __arg0, rules);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection FindEntryPointByName(string name)
            {
                var ___ret = __Internal.FindEntryPointByName(__Instance, name);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.EntryPointReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection SpecializeType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, long specializationArgCount, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection specializationArgs, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
            {
                var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
                var ____arg2 = specializationArgs is null ? __IntPtr.Zero : specializationArgs.__Instance;
                var __arg2 = new __IntPtr(&____arg2);
                var ____arg3 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
                var __arg3 = new __IntPtr(&____arg3);
                var ___ret = __Internal.SpecializeType(__Instance, __arg0, specializationArgCount, __arg2, __arg3);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection SpecializeGeneric(global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection generic, long specializationArgCount, ref global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType specializationArgTypes, global::ShaderSlang.Net.Bindings.Generated.Slang.GenericArgReflection specializationArgVals, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
            {
                var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
                fixed (global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType* __specializationArgTypes2 = &specializationArgTypes)
                {
                    var __arg2 = __specializationArgTypes2;
                    var ____arg3 = specializationArgVals.__Instance;
                    var __arg3 = new __IntPtr(&____arg3);
                    var ____arg4 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
                    var __arg4 = new __IntPtr(&____arg4);
                    var ___ret = __Internal.SpecializeGeneric(__Instance, __arg0, specializationArgCount, __arg2, __arg3, __arg4);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public bool IsSubType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection subType, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection superType)
            {
                var __arg0 = subType is null ? __IntPtr.Zero : subType.__Instance;
                var __arg1 = superType is null ? __IntPtr.Zero : superType.__Instance;
                var ___ret = __Internal.IsSubType(__Instance, __arg0, __arg1);
                return ___ret;
            }

            public string GetHashedString(ulong index, ref ulong outCount)
            {
                fixed (ulong* __outCount1 = &outCount)
                {
                    var __arg1 = __outCount1;
                    var ___ret = __Internal.GetHashedString(__Instance, index, __arg1);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.SlangResult ToJson(global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
            {
                var ____arg0 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
                var __arg0 = new __IntPtr(&____arg0);
                var ___ret = __Internal.ToJson(__Instance, __arg0);
                return ___ret;
            }

            public static global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection Get(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
            {
                var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
                var ___ret = __Internal.Get(__arg0);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public uint ParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetParameterCount(__Instance);
                    return ___ret;
                }
            }

            public uint TypeParameterCount
            {
                get
                {
                    var ___ret = __Internal.GetTypeParameterCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.ISession Session
            {
                get
                {
                    var ___ret = __Internal.GetSession(__Instance);
                    var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.ISession.__CreateInstance(___ret) : default;
                    return __result0;
                }
            }

            public ulong EntryPointCount
            {
                get
                {
                    var ___ret = __Internal.GetEntryPointCount(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the binding index for the global constant buffer.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the binding depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GlobalConstantBufferBinding
            {
                get
                {
                    var ___ret = __Internal.GetGlobalConstantBufferBinding(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the size of the global constant buffer.</summary>
            /// <remarks>
            /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
            /// <para>Returns `SLANG_UNKNOWN_SIZE` when the size depends on unresolved generic parameters or</para>
            /// <para>link-time constants.</para>
            /// </remarks>
            public ulong GlobalConstantBufferSize
            {
                get
                {
                    var ___ret = __Internal.GetGlobalConstantBufferSize(__Instance);
                    return ___ret;
                }
            }

            public ulong HashedStringCount
            {
                get
                {
                    var ___ret = __Internal.GetHashedStringCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection GlobalParamsTypeLayout
            {
                get
                {
                    var ___ret = __Internal.GetGlobalParamsTypeLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection GlobalParamsVarLayout
            {
                get
                {
                    var ___ret = __Internal.GetGlobalParamsVarLayout(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableLayoutReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class DeclReflection : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflectionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection8getChildEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetChild(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12findModifierENS_8Modifier2IDE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindModifier(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection7getNameEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection7getKindEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.Kind GetKind(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection16getChildrenCountEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetChildrenCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection7getTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection10asVariableEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AsVariable(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection10asFunctionEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AsFunction(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection9asGenericEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AsGeneric(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection9getParentEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection11getChildrenEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__Internal GetChildren(__IntPtr __instance);
            }

            public enum Kind
            {
                Unsupported = 0,
                Struct = 1,
                Func = 2,
                Module = 3,
                Generic = 4,
                Variable = 5,
                Namespace = 6
            }

            public unsafe partial class IteratedList : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 16)]
                public partial struct __Internal
                {
                    internal uint count;
                    internal __IntPtr parent;

                    [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12IteratedListC2ERKS1_", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                    [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12IteratedList5beginEv", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal Begin(__IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12IteratedList3endEv", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal End(__IntPtr __instance);
                }

                public unsafe partial class Iterator : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 16)]
                    public partial struct __Internal
                    {
                        internal __IntPtr parent;
                        internal uint count;
                        internal uint index;

                        [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12IteratedList8IteratorC2ERKS2_", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                        [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang14DeclReflection12IteratedList8IteratorneERKS2_", CallingConvention = __CallingConvention.Cdecl)]
                        [return: MarshalAs(UnmanagedType.I1)]
                        internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr other);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static Iterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new Iterator(native.ToPointer(), skipVTables);
                    }

                    internal static Iterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (Iterator)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static Iterator __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new Iterator(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        *(__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Iterator(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected Iterator(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public Iterator()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    public Iterator(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public static bool operator ==(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator __op, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator other)
                    {
                        return !(__op != other);
                    }

                    public override bool Equals(object obj)
                    {
                        return this == obj as global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator;
                    }

                    public override int GetHashCode()
                    {
                        if (__Instance == __IntPtr.Zero)
                            return __IntPtr.Zero.GetHashCode();
                        return (*(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__Internal*) __Instance).GetHashCode();
                    }

                    public static bool operator !=(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator __op, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator other)
                    {
                        bool __opNull = ReferenceEquals(__op, null);
                        bool otherNull = ReferenceEquals(other, null);
                        if (__opNull || otherNull)
                            return !(__opNull && otherNull);
                        var __arg0 = __op.__Instance;
                        var __arg1 = other.__Instance;
                        var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                        return ___ret;
                    }

                    public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection Parent
                    {
                        get
                        {
                            var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                            return __result0;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
                        }
                    }

                    public uint Count
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->count;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->count = value;
                        }
                    }

                    public uint Index
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->index;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->index = value;
                        }
                    }
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static IteratedList __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new IteratedList(native.ToPointer(), skipVTables);
                }

                internal static IteratedList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (IteratedList)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static IteratedList __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new IteratedList(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private IteratedList(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected IteratedList(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public IteratedList()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public IteratedList(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator Begin()
                {
                    var ___ret = __Internal.Begin(__Instance);
                    return global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__CreateInstance(___ret);
                }

                public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator End()
                {
                    var ___ret = __Internal.End(__Instance);
                    return global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.Iterator.__CreateInstance(___ret);
                }

                public uint Count
                {
                    get
                    {
                        return ((__Internal*)__Instance)->count;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->count = value;
                    }
                }

                public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection Parent
                {
                    get
                    {
                        var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                        return __result0;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static DeclReflection __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DeclReflection(native.ToPointer(), skipVTables);
            }

            internal static DeclReflection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DeclReflection)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DeclReflection __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DeclReflection(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DeclReflection(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DeclReflection(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public DeclReflection()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public DeclReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection GetChild(uint index)
            {
                var ___ret = __Internal.GetChild(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier FindModifier(global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.ID id)
            {
                var ___ret = __Internal.FindModifier(__Instance, id);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.Modifier.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public string Name
            {
                get
                {
                    var ___ret = __Internal.GetName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.Kind kind
            {
                get
                {
                    var ___ret = __Internal.GetKind(__Instance);
                    return ___ret;
                }
            }

            public uint ChildrenCount
            {
                get
                {
                    var ___ret = __Internal.GetChildrenCount(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection Type
            {
                get
                {
                    var ___ret = __Internal.GetType(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection AsVariable
            {
                get
                {
                    var ___ret = __Internal.AsVariable(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VariableReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection AsFunction
            {
                get
                {
                    var ___ret = __Internal.AsFunction(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection AsGeneric
            {
                get
                {
                    var ___ret = __Internal.AsGeneric(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.GenericReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection Parent
            {
                get
                {
                    var ___ret = __Internal.GetParent(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList Children
            {
                get
                {
                    var ___ret = __Internal.GetChildren(__Instance);
                    return global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection.IteratedList.__CreateInstance(___ret);
                }
            }
        }

        public unsafe partial class CompileCoreModuleFlag : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang21CompileCoreModuleFlagC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public enum Enum : uint
            {
                WriteDocumentation = 0x1
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static CompileCoreModuleFlag __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new CompileCoreModuleFlag(native.ToPointer(), skipVTables);
            }

            internal static CompileCoreModuleFlag __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (CompileCoreModuleFlag)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static CompileCoreModuleFlag __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CompileCoreModuleFlag(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CompileCoreModuleFlag(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected CompileCoreModuleFlag(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public CompileCoreModuleFlag()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public CompileCoreModuleFlag(global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.CompileCoreModuleFlag.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>A global session for interaction with the Slang library.</summary>
        /// <remarks>
        /// <para>An application may create and re-use a single global session across</para>
        /// <para>multiple sessions, in order to amortize startups costs (in current</para>
        /// <para>Slang this is mostly the cost of loading the Slang standard library).</para>
        /// <para>The global session is currently *not* thread-safe and objects created from</para>
        /// <para>a single global session should only be used from a single thread at</para>
        /// <para>a time.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.GuidAttribute("c140b5fd-0c78-452e-ba7c-1a1e70c7f71c")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IGlobalSession : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            /// <summary>Create a new session for loading and compiling code.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CreateSession(global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc desc, out global::ShaderSlang.Net.Bindings.Generated.Slang.ISession outSession);

            /// <summary>Look up the internal ID of a profile by its `name`.</summary>
            /// <remarks>
            /// <para>Profile IDs are *not* guaranteed to be stable across versions</para>
            /// <para>of the Slang library, so clients are expected to look up</para>
            /// <para>profiles by name at runtime.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.SlangProfileID FindProfile(string name);

            /// <summary>
            /// <para>Set the path that downstream compilers (aka back end compilers) will</para>
            /// <para>be looked from.</para>
            /// </summary>
            /// <param name="passThrough">Identifies the downstream compiler</param>
            /// <param name="path">The path to find the downstream compiler (shared library/dll/executable)</param>
            /// <remarks>
            /// <para>For back ends that are dlls/shared libraries, it will mean the path will</para>
            /// <para>be prefixed with the path when calls are made out to ISlangSharedLibraryLoader.</para>
            /// <para>For executables - it will look for executables along the path </para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDownstreamCompilerPath(global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough, string path);

            /// <summary>DEPRECATED: Use setLanguagePrelude</summary>
            /// <param name="passThrough">
            /// <para>The downstream compiler for generated code that will have the prelude applied</para>
            /// <para>to it.</para>
            /// </param>
            /// <param name="preludeText">The text added pre-pended verbatim before the generated source</param>
            /// <remarks>
            /// <para>Set the 'prelude' for generated code for a 'downstream compiler'.</para>
            /// <para>That for pass-through usage, prelude is not pre-pended, preludes are for code generation only.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDownstreamCompilerPrelude(global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough, string preludeText);

            /// <summary>DEPRECATED: Use getLanguagePrelude</summary>
            /// <param name="passThrough">
            /// <para>The downstream compiler for generated code that will have the prelude applied</para>
            /// <para>to it.</para>
            /// </param>
            /// <param name="outPrelude">On exit holds a blob that holds the string of the prelude.</param>
            /// <remarks>Get the 'prelude' for generated code for a 'downstream compiler'.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void GetDownstreamCompilerPrelude(global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outPrelude);

            /// <summary>
            /// <para>Get the build version 'tag' string. The string is the same as produced via `git describe</para>
            /// <para>--tags` for the project. If Slang is built separately from the automated build scripts the</para>
            /// <para>contents will by default be 'unknown'. Any string can be set by changing the contents of</para>
            /// <para>'slang-tag-version.h' file and recompiling the project.</para>
            /// </summary>
            /// <returns>The build tag string</returns>
            /// <remarks>This method will return exactly the same result as the free function spGetBuildTagString.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetBuildTagString();

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetDefaultDownstreamCompiler(global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage sourceLanguage, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough defaultCompiler);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough GetDefaultDownstreamCompiler(global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage sourceLanguage);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetLanguagePrelude(global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage sourceLanguage, string preludeText);

            /// <summary>Get the 'prelude' associated with a specific source language.</summary>
            /// <param name="sourceLanguage">The language the prelude should be inserted on.</param>
            /// <param name="outPrelude">On exit holds a blob that holds the string of the prelude.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void GetLanguagePrelude(global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage sourceLanguage, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outPrelude);

            /// <summary>Create a compile request.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CreateCompileRequest(out global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest outCompileRequest);

            /// <summary>Add new builtin declarations to be used in subsequent compiles.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddBuiltins(string sourcePath, string sourceString);

            /// <summary>
            /// <para>Set the session shared library loader. If this changes the loader, it may cause shared</para>
            /// <para>libraries to be unloaded</para>
            /// </summary>
            /// <param name="loader">The loader to set. Setting nullptr sets the default loader.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetSharedLibraryLoader(global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibraryLoader loader);

            /// <summary>Gets the currently set shared library loader</summary>
            /// <returns>Gets the currently set loader. If returns nullptr, it's the default loader</returns>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibraryLoader GetSharedLibraryLoader();

            /// <summary>Returns SLANG_OK if the compilation target is supported for this session</summary>
            /// <param name="target">The compilation target to test</param>
            /// <returns>
            /// <para>SLANG_OK if the target is available</para>
            /// <para>SLANG_E_NOT_IMPLEMENTED if not implemented in this build</para>
            /// <para>SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work</para>
            /// <para>could not be found SLANG_FAIL other kinds of failures</para>
            /// </returns>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CheckCompileTargetSupport(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            /// <summary>Returns SLANG_OK if the pass through support is supported for this session</summary>
            /// <param name="session">Session</param>
            /// <param name="target">The compilation target to test</param>
            /// <returns>
            /// <para>SLANG_OK if the target is available</para>
            /// <para>SLANG_E_NOT_IMPLEMENTED if not implemented in this build</para>
            /// <para>SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work</para>
            /// <para>could not be found SLANG_FAIL other kinds of failures</para>
            /// </returns>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CheckPassThroughSupport(global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough);

            /// <summary>
            /// <para>Compile from (embedded source) the core module on the session.</para>
            /// <para>Will return a failure if there is already a core module available</para>
            /// <para>NOTE! API is experimental and not ready for production code</para>
            /// </summary>
            /// <param name="flags">to control compilation</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CompileCoreModule(uint flags);

            /// <summary>Load the core module. Currently loads modules from the file system.</summary>
            /// <param name="coreModule">Start address of the serialized core module</param>
            /// <param name="coreModuleSizeInBytes">The size in bytes of the serialized core module</param>
            /// <remarks>NOTE! API is experimental and not ready for production code</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LoadCoreModule(__IntPtr coreModule, ulong coreModuleSizeInBytes);

            /// <summary>Save the core module to the file system</summary>
            /// <param name="archiveType">The type of archive used to hold the core module</param>
            /// <param name="outBlob">The serialized blob containing the core module</param>
            /// <remarks>NOTE! API is experimental and not ready for production code  </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SaveCoreModule(global::ShaderSlang.Net.Bindings.Generated.SlangArchiveType archiveType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Look up the internal ID of a capability by its `name`.</summary>
            /// <remarks>
            /// <para>Capability IDs are *not* guaranteed to be stable across versions</para>
            /// <para>of the Slang library, so clients are expected to look up</para>
            /// <para>capabilities by name at runtime.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID FindCapability(string name);

            /// <summary>
            /// <para>Set the downstream/pass through compiler to be used for a transition from the source type to</para>
            /// <para>the target type</para>
            /// </summary>
            /// <param name="source">The source 'code gen target'</param>
            /// <param name="target">The target 'code gen target'</param>
            /// <param name="compiler">The compiler/pass through to use for the transition from source to target</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDownstreamCompilerForTransition(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget source, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough compiler);

            /// <summary>Get the downstream/pass through compiler for a transition specified by source and target</summary>
            /// <param name="source">The source 'code gen target'</param>
            /// <param name="target">The target 'code gen target'</param>
            /// <returns>
            /// <para>The compiler that is used for the transition. Returns SLANG_PASS_THROUGH_NONE it is not</para>
            /// <para>defined</para>
            /// </returns>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough GetDownstreamCompilerForTransition(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget source, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            /// <summary>Get the time in seconds spent in the slang and downstream compiler.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void GetCompilerElapsedTime(out double outTotalTime, out double outDownstreamTime);

            /// <summary>
            /// <para>Specify a spirv.core.grammar.json file to load and use when</para>
            /// <para>parsing and checking any SPIR-V code</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetSPIRVCoreGrammar(string jsonPath);

            /// <summary>
            /// <para>Parse slangc command line options into a SessionDesc that can be used to create a session</para>
            /// <para>with all the compiler options specified in the command line.</para>
            /// </summary>
            /// <param name="argc">The number of command line arguments.</param>
            /// <param name="argv">An input array of command line arguments to parse.</param>
            /// <param name="outSessionDesc">A pointer to a SessionDesc struct to receive parsed session desc.</param>
            /// <param name="outAuxAllocation">Auxiliary memory allocated to hold data used in the session desc.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult ParseCommandLineArguments(int argc, char** argv, out global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc outSessionDesc, out global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown outAuxAllocation);

            /// <summary>Computes a digest that uniquely identifies the session description.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetSessionDescDigest(global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc sessionDesc, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>
            /// <para>Compile from (embedded source) the builtin module on the session.</para>
            /// <para>Will return a failure if there is already a builtin module available.</para>
            /// <para>NOTE! API is experimental and not ready for production code.</para>
            /// </summary>
            /// <param name="module">The builtin module name.</param>
            /// <param name="flags">to control compilation</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CompileBuiltinModule(global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName module, uint flags);

            /// <summary>Load a builtin module. Currently loads modules from the file system.</summary>
            /// <param name="module">The builtin module name</param>
            /// <param name="moduleData">Start address of the serialized core module</param>
            /// <param name="sizeInBytes">The size in bytes of the serialized builtin module</param>
            /// <remarks>NOTE! API is experimental and not ready for production code</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LoadBuiltinModule(global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName module, __IntPtr moduleData, ulong sizeInBytes);

            /// <summary>Save the builtin module to the file system</summary>
            /// <param name="module">The builtin module name</param>
            /// <param name="archiveType">The type of archive used to hold the builtin module</param>
            /// <param name="outBlob">The serialized blob containing the builtin module</param>
            /// <remarks>NOTE! API is experimental and not ready for production code  </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SaveBuiltinModule(global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName module, global::ShaderSlang.Net.Bindings.Generated.SlangArchiveType archiveType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);
        }

        /// <summary>Description of a code generation target.</summary>
        public unsafe partial class TargetDesc : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal ulong structureSize;
                internal global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget format;
                internal global::ShaderSlang.Net.Bindings.Generated.SlangProfileID profile;
                internal uint flags;
                internal global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode floatingPointMode;
                internal global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode lineDirectiveMode;
                internal byte forceGLSLScalarBufferLayout;
                internal __IntPtr compilerOptionEntries;
                internal uint compilerOptionEntryCount;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang10TargetDescC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang10TargetDescC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static TargetDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new TargetDesc(native.ToPointer(), skipVTables);
            }

            internal static TargetDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (TargetDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static TargetDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TargetDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TargetDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected TargetDesc(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TargetDesc()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public TargetDesc(global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The size of this structure, in bytes.</summary>
            public ulong StructureSize
            {
                get
                {
                    return ((__Internal*)__Instance)->structureSize;
                }

                set
                {
                    ((__Internal*)__Instance)->structureSize = value;
                }
            }

            /// <summary>The target format to generate code for (e.g., SPIR-V, DXIL, etc.)</summary>
            public global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget Format
            {
                get
                {
                    return ((__Internal*)__Instance)->format;
                }

                set
                {
                    ((__Internal*)__Instance)->format = value;
                }
            }

            /// <summary>The compilation profile supported by the target (e.g., &quot;Shader Model 5.1&quot;)</summary>
            public global::ShaderSlang.Net.Bindings.Generated.SlangProfileID Profile
            {
                get
                {
                    return ((__Internal*)__Instance)->profile;
                }

                set
                {
                    ((__Internal*)__Instance)->profile = value;
                }
            }

            /// <summary>Flags for the code generation target. Currently unused. </summary>
            public uint Flags
            {
                get
                {
                    return ((__Internal*)__Instance)->flags;
                }

                set
                {
                    ((__Internal*)__Instance)->flags = value;
                }
            }

            /// <summary>Default mode to use for floating-point operations on the target.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode FloatingPointMode
            {
                get
                {
                    return ((__Internal*)__Instance)->floatingPointMode;
                }

                set
                {
                    ((__Internal*)__Instance)->floatingPointMode = value;
                }
            }

            /// <summary>The line directive mode for output source code.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode LineDirectiveMode
            {
                get
                {
                    return ((__Internal*)__Instance)->lineDirectiveMode;
                }

                set
                {
                    ((__Internal*)__Instance)->lineDirectiveMode = value;
                }
            }

            /// <summary>Whether to force `scalar` layout for glsl shader storage buffers.</summary>
            public bool ForceGLSLScalarBufferLayout
            {
                get
                {
                    return ((__Internal*)__Instance)->forceGLSLScalarBufferLayout != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->forceGLSLScalarBufferLayout = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry CompilerOptionEntries
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__GetOrCreateInstance(((__Internal*)__Instance)->compilerOptionEntries, false);
                    return __result0;
                }
            }

            /// <summary>Number of additional compiler option entries.</summary>
            public uint CompilerOptionEntryCount
            {
                get
                {
                    return ((__Internal*)__Instance)->compilerOptionEntryCount;
                }

                set
                {
                    ((__Internal*)__Instance)->compilerOptionEntryCount = value;
                }
            }
        }

        public unsafe partial class PreprocessorMacroDesc : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr name;
                internal __IntPtr value;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang21PreprocessorMacroDescC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            private bool __name_OwnsNativeMemory = false;
            private bool __value_OwnsNativeMemory = false;
            protected bool __ownsNativeInstance;

            internal static PreprocessorMacroDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PreprocessorMacroDesc(native.ToPointer(), skipVTables);
            }

            internal static PreprocessorMacroDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PreprocessorMacroDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PreprocessorMacroDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PreprocessorMacroDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PreprocessorMacroDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PreprocessorMacroDesc(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public PreprocessorMacroDesc()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public PreprocessorMacroDesc(global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc.__Internal*) _0.__Instance);
                if (_0.__name_OwnsNativeMemory)
                    this.Name = _0.Name;
                if (_0.__value_OwnsNativeMemory)
                    this.Value = _0.Value;
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                if (__value_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->value);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string Name
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
                }

                set
                {
                    if (__name_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                    __name_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
                }
            }

            public string Value
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->value);
                }

                set
                {
                    if (__value_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->value);
                    __value_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->value = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->value = (__IntPtr) __bytePtr0;
                }
            }
        }

        public unsafe partial class SessionDesc : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public partial struct __Internal
            {
                internal ulong structureSize;
                internal __IntPtr targets;
                internal long targetCount;
                internal uint flags;
                internal global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode defaultMatrixLayoutMode;
                internal __IntPtr searchPaths;
                internal long searchPathCount;
                internal __IntPtr preprocessorMacros;
                internal long preprocessorMacroCount;
                internal __IntPtr fileSystem;
                internal byte enableEffectAnnotations;
                internal byte allowGLSLSyntax;
                internal __IntPtr compilerOptionEntries;
                internal uint compilerOptionEntryCount;
                internal byte skipSPIRVValidation;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang11SessionDescC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang11SessionDescC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SessionDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SessionDesc(native.ToPointer(), skipVTables);
            }

            internal static SessionDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SessionDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SessionDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SessionDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SessionDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SessionDesc(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SessionDesc()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public SessionDesc(global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.SessionDesc.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The size of this structure, in bytes.</summary>
            public ulong StructureSize
            {
                get
                {
                    return ((__Internal*)__Instance)->structureSize;
                }

                set
                {
                    ((__Internal*)__Instance)->structureSize = value;
                }
            }

            /// <summary>Code generation targets to include in the session.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc Targets
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TargetDesc.__GetOrCreateInstance(((__Internal*)__Instance)->targets, false);
                    return __result0;
                }
            }

            public long TargetCount
            {
                get
                {
                    return ((__Internal*)__Instance)->targetCount;
                }

                set
                {
                    ((__Internal*)__Instance)->targetCount = value;
                }
            }

            /// <summary>Flags to configure the session.</summary>
            public uint Flags
            {
                get
                {
                    return ((__Internal*)__Instance)->flags;
                }

                set
                {
                    ((__Internal*)__Instance)->flags = value;
                }
            }

            /// <summary>Default layout to assume for variables with matrix types.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode DefaultMatrixLayoutMode
            {
                get
                {
                    return ((__Internal*)__Instance)->defaultMatrixLayoutMode;
                }

                set
                {
                    ((__Internal*)__Instance)->defaultMatrixLayoutMode = value;
                }
            }

            /// <summary>Paths to use when searching for `#include`d or `import`ed files.</summary>
            public char** SearchPaths
            {
                get
                {
                    return (char**) ((__Internal*)__Instance)->searchPaths;
                }
            }

            public long SearchPathCount
            {
                get
                {
                    return ((__Internal*)__Instance)->searchPathCount;
                }

                set
                {
                    ((__Internal*)__Instance)->searchPathCount = value;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc PreprocessorMacros
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.PreprocessorMacroDesc.__GetOrCreateInstance(((__Internal*)__Instance)->preprocessorMacros, false);
                    return __result0;
                }
            }

            public long PreprocessorMacroCount
            {
                get
                {
                    return ((__Internal*)__Instance)->preprocessorMacroCount;
                }

                set
                {
                    ((__Internal*)__Instance)->preprocessorMacroCount = value;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem FileSystem
            {
                get
                {
                    var __result0 = ((__Internal*)__Instance)->fileSystem != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem.__CreateInstance(((__Internal*)__Instance)->fileSystem) : default;
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->fileSystem = value is null ? __IntPtr.Zero : value.__PointerToISlangFileSystem;
                }
            }

            public bool EnableEffectAnnotations
            {
                get
                {
                    return ((__Internal*)__Instance)->enableEffectAnnotations != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->enableEffectAnnotations = (byte) (value ? 1 : 0);
                }
            }

            public bool AllowGLSLSyntax
            {
                get
                {
                    return ((__Internal*)__Instance)->allowGLSLSyntax != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->allowGLSLSyntax = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.</summary>
            public global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry CompilerOptionEntries
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry.__GetOrCreateInstance(((__Internal*)__Instance)->compilerOptionEntries, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->compilerOptionEntries = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>Number of additional compiler option entries.</summary>
            public uint CompilerOptionEntryCount
            {
                get
                {
                    return ((__Internal*)__Instance)->compilerOptionEntryCount;
                }

                set
                {
                    ((__Internal*)__Instance)->compilerOptionEntryCount = value;
                }
            }

            /// <summary>Whether to skip SPIRV validation.</summary>
            public bool SkipSPIRVValidation
            {
                get
                {
                    return ((__Internal*)__Instance)->skipSPIRVValidation != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->skipSPIRVValidation = (byte) (value ? 1 : 0);
                }
            }
        }

        /// <summary>A session provides a scope for code that is loaded.</summary>
        /// <remarks>
        /// <para>A session can be used to load modules of Slang source code,</para>
        /// <para>and to request target-specific compiled binaries and layout</para>
        /// <para>information.</para>
        /// <para>In order to be able to load code, the session owns a set</para>
        /// <para>of active &quot;search paths&quot; for resolving `#include` directives</para>
        /// <para>and `import` declarations, as well as a set of global</para>
        /// <para>preprocessor definitions that will be used for all code</para>
        /// <para>that gets `import`ed in the session.</para>
        /// <para>If multiple user shaders are loaded in the same session,</para>
        /// <para>and import the same module (e.g., two source files do `import X`)</para>
        /// <para>then there will only be one copy of `X` loaded within the session.</para>
        /// <para>In order to be able to generate target code, the session</para>
        /// <para>owns a list of available compilation targets, which specify</para>
        /// <para>code generation options.</para>
        /// <para>Code loaded and compiled within a session is owned by the session</para>
        /// <para>and will remain resident in memory until the session is released.</para>
        /// <para>Applications wishing to control the memory usage for compiled</para>
        /// <para>and loaded code should use multiple sessions.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.GuidAttribute("67618701-d116-468f-ab3b-474bedce0e3d")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface ISession : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            /// <summary>Get the global session thas was used to create this session.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession GetGlobalSession();

            /// <summary>Load a module as it would be by code using `import`.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IModule LoadModule(string moduleName, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Load a module from Slang source code.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IModule LoadModuleFromSource(string moduleName, string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob source, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Combine multiple component types to create a composite component type.</summary>
            /// <remarks>
            /// <para>The `componentTypes` array must contain `componentTypeCount` pointers</para>
            /// <para>to component types that were loaded or created using the same session.</para>
            /// <para>The shader parameters and specialization parameters of the composite will</para>
            /// <para>be the union of those in `componentTypes`. The relative order of child</para>
            /// <para>component types is significant, and will affect the order in which</para>
            /// <para>parameters are reflected and laid out.</para>
            /// <para>The entry-point functions of the composite will be the union of those in</para>
            /// <para>`componentTypes`, and will follow the ordering of `componentTypes`.</para>
            /// <para>The requirements of the composite component type will be a subset of</para>
            /// <para>those in `componentTypes`. If an entry in `componentTypes` has a requirement</para>
            /// <para>that can be satisfied by another entry, then the composition will</para>
            /// <para>satisfy the requirement and it will not appear as a requirement of</para>
            /// <para>the composite. If multiple entries in `componentTypes` have a requirement</para>
            /// <para>for the same type, then only the first such requirement will be retained</para>
            /// <para>on the composite. The relative ordering of requirements on the composite</para>
            /// <para>will otherwise match that of `componentTypes`.</para>
            /// <para>If any diagnostics are generated during creation of the composite, they</para>
            /// <para>will be written to `outDiagnostics`. If an error is encountered, the</para>
            /// <para>function will return null.</para>
            /// <para>It is an error to create a composite component type that recursively</para>
            /// <para>aggregates a single module more than once.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CreateCompositeComponentType(global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType componentTypes, long componentTypeCount, out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outCompositeComponentType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Specialize a type based on type arguments.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection SpecializeType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg specializationArgs, long specializationArgCount, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Get the layout `type` on the chosen `target`.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.TypeLayoutReflection GetTypeLayout(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, long targetIndex, global::ShaderSlang.Net.Bindings.Generated.Slang.LayoutRules rules, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>
            /// <para>Get a container type from `elementType`. For example, given type `T`, returns</para>
            /// <para>a type that represents `StructuredBuffer<T>`.</para>
            /// </summary>
            /// <param name="`elementType`:">the element type to wrap around.</param>
            /// <param name="`containerType`:">the type of the container to wrap `elementType` in.</param>
            /// <param name="`outDiagnostics`:">a blob to receive diagnostic messages.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetContainerType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection elementType, global::ShaderSlang.Net.Bindings.Generated.Slang.ContainerType containerType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>
            /// <para>Return a `TypeReflection` that represents the `__Dynamic` type.</para>
            /// <para>This type can be used as a specialization argument to indicate using</para>
            /// <para>dynamic dispatch.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection GetDynamicType();

            /// <summary>Get the mangled name for a type RTTI object.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTypeRTTIMangledName(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outNameBlob);

            /// <summary>Get the mangled name for a type witness.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTypeConformanceWitnessMangledName(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection interfaceType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outNameBlob);

            /// <summary>
            /// <para>Get the sequential ID used to identify a type witness in a dynamic object.</para>
            /// <para>The sequential ID is part of the RTTI bytes returned by `getDynamicObjectRTTIBytes`.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTypeConformanceWitnessSequentialID(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection interfaceType, out uint outId);

            /// <summary>Create a request to load/compile front-end code.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CreateCompileRequest(out global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest outCompileRequest);

            /// <summary>
            /// <para>Creates a `IComponentType` that represents a type's conformance to an interface.</para>
            /// <para>The retrieved `ITypeConformance` objects can be included in a composite `IComponentType`</para>
            /// <para>to explicitly specify which implementation types should be included in the final compiled</para>
            /// <para>code. For example, if an module defines `IMaterial` interface and `AMaterial`,</para>
            /// <para>`BMaterial`, `CMaterial` types that implements the interface, the user can exclude</para>
            /// <para>`CMaterial` implementation from the resulting shader code by explicitly adding</para>
            /// <para>`AMaterial:IMaterial` and `BMaterial:IMaterial` conformances to a composite</para>
            /// <para>`IComponentType` and get entry point code from it. The resulting code will not have</para>
            /// <para>anything related to `CMaterial` in the dynamic dispatch logic. If the user does not</para>
            /// <para>explicitly include any `TypeConformances` to an interface type, all implementations to</para>
            /// <para>that interface will be included by default. By linking a `ITypeConformance`, the user is</para>
            /// <para>also given the opportunity to specify the dispatch ID of the implementation type. If</para>
            /// <para>`conformanceIdOverride` is -1, there will be no override behavior and Slang will</para>
            /// <para>automatically assign IDs to implementation types. The automatically assigned IDs can be</para>
            /// <para>queried via `ISession::getTypeConformanceWitnessSequentialID`.</para>
            /// </summary>
            /// <remarks>Returns SLANG_OK if succeeds, or SLANG_FAIL if `type` does not conform to `interfaceType`.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult CreateTypeConformanceComponentType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection interfaceType, out global::ShaderSlang.Net.Bindings.Generated.Slang.ITypeConformance outConformance, long conformanceIdOverride, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Load a module from a Slang module blob.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IModule LoadModuleFromIRBlob(string moduleName, string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob source, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            long GetLoadedModuleCount();

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IModule GetLoadedModule(long index);

            /// <summary>
            /// <para>Checks if a precompiled binary module is up-to-date with the current compiler</para>
            /// <para>option settings and the source file contents.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            [return: global::System.Runtime.InteropServices.MarshalAsAttribute(global::System.Runtime.InteropServices.UnmanagedType.I1)]
            bool IsBinaryModuleUpToDate(string modulePath, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob binaryModuleBlob);

            /// <summary>Load a module from a string.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.IModule LoadModuleFromSourceString(string moduleName, string path, string @string, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>
            /// <para>Get the 16-byte RTTI header to fill into a dynamic object.</para>
            /// <para>This header is used to identify the type of the object for dynamic dispatch purpose.</para>
            /// <para>For example, given the following shader:</para>
            /// </summary>
            /// <remarks>
            /// <para>```slang</para>
            /// <para>[anyValueSize(32)] dyn interface IFoo { int eval(); }</para>
            /// <para>struct Impl : IFoo { int eval() { return 1; } }</para>
            /// <para>ConstantBuffer<dyn IFoo="">cb0;</para>
            /// <para>[numthreads(1,1,1)</para>
            /// <para>void main()</para>
            /// <para>{</para>
            /// <para>cb0.eval();</para>
            /// <para>}</para>
            /// <para>```</para>
            /// <para>The constant buffer `cb0` should be filled with 16+32=48 bytes of data, where the first</para>
            /// <para>16 bytes should be the RTTI bytes returned by calling `getDynamicObjectRTTIBytes(type_Impl,</para>
            /// <para>type_IFoo)`, and the rest 32 bytes should hold the actual data of the dynamic object (in</para>
            /// <para>this case, fields in the `Impl` type).</para>
            /// <para>`bufferSizeInBytes` must be greater than 16.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetDynamicObjectRTTIBytes(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection type, global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection interfaceType, out uint outRTTIDataBuffer, uint bufferSizeInBytes);

            /// <summary>Read module info (name and version) from a module blob</summary>
            /// <remarks>The returned pointers are valid for as long as the session.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LoadModuleInfoFromIRBlob(global::ShaderSlang.Net.Bindings.Generated.ISlangBlob source, out long outModuleVersion, out string outModuleCompilerVersion, out string outModuleName);
        }

        [global::System.Runtime.InteropServices.GuidAttribute("8044a8a3-ddc0-4b7f-af8e-026e905d7332")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IMetadata : global::ShaderSlang.Net.Bindings.Generated.ISlangCastable
        {
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult IsParameterLocationUsed(global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category, ulong spaceIndex, ulong registerIndex, out bool outUsed);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetDebugBuildIdentifier();
        }

        /// <summary>
        /// <para>Compile result for storing and retrieving multiple output blobs.</para>
        /// <para>This is needed for features such as separate debug compilation which</para>
        /// <para>output both base and debug spirv.</para>
        /// </summary>
        [global::System.Runtime.InteropServices.GuidAttribute("5fa9380e-b62f-41e5-9f12-4bad4d9eaae4")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface ICompileResult : global::ShaderSlang.Net.Bindings.Generated.ISlangCastable
        {
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            uint GetItemCount();

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetItemData(uint index, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outblob);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetMetadata(out global::ShaderSlang.Net.Bindings.Generated.Slang.IMetadata outMetadata);
        }

        /// <summary>A component type is a unit of shader code layout, reflection, and linking.</summary>
        /// <remarks>
        /// <para>A component type is a unit of shader code that can be included into</para>
        /// <para>a linked and compiled shader program. Each component type may have:</para>
        /// <para>Zero or more uniform shader parameters, representing textures,</para>
        /// <para>buffers, etc. that the code in the component depends on.</para>
        /// <para>Zero or more *specialization* parameters, which are type or</para>
        /// <para>value parameters that can be used to synthesize specialized</para>
        /// <para>versions of the component type.</para>
        /// <para>Zero or more entry points, which are the individually invocable</para>
        /// <para>kernels that can have final code generated.</para>
        /// <para>Zero or more *requirements*, which are other component</para>
        /// <para>types on which the component type depends.</para>
        /// <para>One example of a component type is a module of Slang code:</para>
        /// <para>The global-scope shader parameters declared in the module are</para>
        /// <para>the parameters when considered as a component type.</para>
        /// <para>Any global-scope generic or interface type parameters introduce</para>
        /// <para>specialization parameters for the module.</para>
        /// <para>A module does not by default include any entry points when</para>
        /// <para>considered as a component type (although the code of the</para>
        /// <para>module might *declare* some entry points).</para>
        /// <para>Any other modules that are `import`ed in the source code</para>
        /// <para>become requirements of the module, when considered as a</para>
        /// <para>component type.</para>
        /// <para>An entry point is another example of a component type:</para>
        /// <para>The `uniform` parameters of the entry point function are</para>
        /// <para>its shader parameters when considered as a component type.</para>
        /// <para>Any generic or interface-type parameters of the entry point</para>
        /// <para>introduce specialization parameters.</para>
        /// <para>An entry point component type exposes a single entry point (itself).</para>
        /// <para>An entry point has one requirement for the module in which</para>
        /// <para>it was defined.</para>
        /// <para>Component types can be manipulated in a few ways:</para>
        /// <para>Multiple component types can be combined into a composite, which</para>
        /// <para>combines all of their code, parameters, etc.</para>
        /// <para>A component type can be specialized, by &quot;plugging in&quot; types and</para>
        /// <para>values for its specialization parameters.</para>
        /// <para>A component type can be laid out for a particular target, giving</para>
        /// <para>offsets/bindings to the shader parameters it contains.</para>
        /// <para>Generated kernel code can be requested for entry points.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.GuidAttribute("5bc42be8-5c50-4929-9e5e-d15e7c24015f")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IComponentType : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            /// <summary>Get the runtime session that this component type belongs to.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.ISession GetSession();

            /// <summary>Get the layout for this program for the chosen `targetIndex`.</summary>
            /// <remarks>
            /// <para>The resulting layout will establish offsets/bindings for all</para>
            /// <para>of the global and entry-point shader parameters in the</para>
            /// <para>component type.</para>
            /// <para>If this component type has specialization parameters (that is,</para>
            /// <para>it is not fully specialized), then the resulting layout may</para>
            /// <para>be incomplete, and plugging in arguments for generic specialization</para>
            /// <para>parameters may result in a component type that doesn't have</para>
            /// <para>a compatible layout. If the component type only uses</para>
            /// <para>interface-type specialization parameters, then the layout</para>
            /// <para>for a specialization should be compatible with an unspecialized</para>
            /// <para>layout (all parameters in the unspecialized layout will have</para>
            /// <para>the same offset/binding in the specialized layout).</para>
            /// <para>If this component type is combined into a composite, then</para>
            /// <para>the absolute offsets/bindings of parameters may not stay the same.</para>
            /// <para>If the shader parameters in a component type don't make</para>
            /// <para>use of explicit binding annotations (e.g., `register(...)`),</para>
            /// <para>then the *relative* offset of shader parameters will stay</para>
            /// <para>the same when it is used in a composition.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.ShaderReflection GetLayout(long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Get the number of (unspecialized) specialization parameters for the component type.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            long GetSpecializationParamCount();

            /// <summary>Get the compiled code for the entry point at `entryPointIndex` for the chosen `targetIndex`</summary>
            /// <remarks>
            /// <para>Entry point code can only be computed for a component type that</para>
            /// <para>has no specialization parameters (it must be fully specialized)</para>
            /// <para>and that has no requirements (it must be fully linked).</para>
            /// <para>If code has not already been generated for the given entry point and target,</para>
            /// <para>then a compilation error may be detected, in which case `outDiagnostics`</para>
            /// <para>(if non-null) will be filled in with a blob of messages diagnosing the error.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointCode(long entryPointIndex, long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outCode, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Get the compilation result as a file system.</summary>
            /// <remarks>
            /// <para>Has the same requirements as getEntryPointCode.</para>
            /// <para>The result is not written to the actual OS file system, but is made available as an</para>
            /// <para>in memory representation.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetResultAsFileSystem(long entryPointIndex, long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangMutableFileSystem outFileSystem);

            /// <summary>Compute a hash for the entry point at `entryPointIndex` for the chosen `targetIndex`.</summary>
            /// <remarks>
            /// <para>This computes a hash based on all the dependencies for this component type as well as the</para>
            /// <para>target settings affecting the compiler backend. The computed hash is used as a key for caching</para>
            /// <para>the output of the compiler backend to implement shader caching.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void GetEntryPointHash(long entryPointIndex, long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outHash);

            /// <summary>Specialize the component by binding its specialization parameters to concrete arguments.</summary>
            /// <remarks>
            /// <para>The `specializationArgs` array must have `specializationArgCount` entries, and</para>
            /// <para>this must match the number of specialization parameters on this component type.</para>
            /// <para>If any diagnostics (error or warnings) are produced, they will be written to `outDiagnostics`.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Specialize(global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg specializationArgs, long specializationArgCount, out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outSpecializedComponentType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Link this component type against all of its unsatisfied dependencies.</summary>
            /// <remarks>
            /// <para>A component type may have unsatisfied dependencies. For example, a module</para>
            /// <para>depends on any other modules it `import`s, and an entry point depends</para>
            /// <para>on the module that defined it.</para>
            /// <para>A user can manually satisfy dependencies by creating a composite</para>
            /// <para>component type, and when doing so they retain full control over</para>
            /// <para>the relative ordering of shader parameters in the resulting layout.</para>
            /// <para>It is an error to try to generate/access compiled kernel code for</para>
            /// <para>a component type with unresolved dependencies, so if dependencies</para>
            /// <para>remain after whatever manual composition steps an application</para>
            /// <para>cares to perform, the `link()` function can be used to automatically</para>
            /// <para>compose in any remaining dependencies. The order of parameters</para>
            /// <para>(and hence the global layout) that results will be deterministic,</para>
            /// <para>but is not currently documented.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Link(out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outLinkedComponentType, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.</summary>
            /// <param name="entryPointIndex">The index of the entry point to get code for.</param>
            /// <param name="targetIndex">The index of the target to get code for (default: zero).</param>
            /// <param name="outSharedLibrary">
            /// <para>A pointer to a ISharedLibrary interface which functions can be queried</para>
            /// <para>on.</para>
            /// </param>
            /// <remarks>
            /// <para>The functions remain in scope as long as the ISlangSharedLibrary interface is in scope.</para>
            /// <para>NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.</para>
            /// <para>A `SlangResult` to indicate success or failure.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointHostCallable(int entryPointIndex, int targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary outSharedLibrary, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>Get a new ComponentType object that represents a renamed entry point.</summary>
            /// <remarks>
            /// <para>The current object must be a single EntryPoint, or a CompositeComponentType or</para>
            /// <para>SpecializedComponentType that contains one EntryPoint component.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult RenameEntryPoint(string newName, out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outEntryPoint);

            /// <summary>
            /// <para>Link and specify additional compiler options when generating code</para>
            /// <para>from the linked program.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LinkWithOptions(out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outLinkedComponentType, uint compilerOptionEntryCount, global::ShaderSlang.Net.Bindings.Generated.Slang.CompilerOptionEntry compilerOptionEntries, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTargetCode(long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outCode, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTargetMetadata(long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.IMetadata outMetadata, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointMetadata(long entryPointIndex, long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.IMetadata outMetadata, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);
        }

        [global::System.Runtime.InteropServices.GuidAttribute("8f241361-f5bd-4ca0-a3ac-02f7fa2402b8")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IEntryPoint : global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType
        {
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.FunctionReflection GetFunctionReflection();
        }

        [global::System.Runtime.InteropServices.GuidAttribute("73eb3147-e544-41b5-b8f0-a244df21940b")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface ITypeConformance : global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType
        {
        }

        /// <summary>IComponentType2 is a component type used for getting separate debug data.</summary>
        /// <remarks>
        /// <para>This interface is used for getting separate debug data, introduced here to</para>
        /// <para>avoid breaking backwards compatibility of the IComponentType interface.</para>
        /// <para>The `getTargetCompileResult` and `getEntryPointCompileResult` functions</para>
        /// <para>are used to get the base and debug spirv, and metadata containing the</para>
        /// <para>debug build identifier.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.GuidAttribute("9c2a4b3d-7f68-4e91-a52c-8b193e457a9f")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IComponentType2 : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTargetCompileResult(long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileResult outCompileResult, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointCompileResult(long entryPointIndex, long targetIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileResult outCompileResult, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);
        }

        /// <summary>A module is the granularity of shader code compilation and loading.</summary>
        /// <remarks>
        /// <para>In most cases a module corresponds to a single compile &quot;translation unit.&quot;</para>
        /// <para>This will often be a single `.slang` or `.hlsl` file and everything it</para>
        /// <para>`#include`s.</para>
        /// <para>Notably, a module `M` does *not* include the things it `import`s, as these</para>
        /// <para>as distinct modules that `M` depends on. There is a directed graph of</para>
        /// <para>module dependencies, and all modules in the graph must belong to the</para>
        /// <para>same session (`ISession`).</para>
        /// <para>A module establishes a namespace for looking up types, functions, etc.</para>
        /// </remarks>
        [global::System.Runtime.InteropServices.GuidAttribute("0c720e64-8722-4d31-8990-638a98b1c279")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IModule : global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType
        {
            /// <summary>
            /// <para>Find and an entry point by name.</para>
            /// <para>Note that this does not work in case the function is not explicitly designated as an entry</para>
            /// <para>point, e.g. using a `[shader(&quot;...&quot;)]` attribute. In such cases, consider using</para>
            /// <para>`IModule::findAndCheckEntryPoint` instead.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult FindEntryPointByName(string name, out global::ShaderSlang.Net.Bindings.Generated.Slang.IEntryPoint outEntryPoint);

            /// <summary>
            /// <para>Get number of entry points defined in the module. An entry point defined in a module</para>
            /// <para>is by default not included in the linkage, so calls to `IComponentType::getEntryPointCount`</para>
            /// <para>on an `IModule` instance will always return 0. However `IModule::getDefinedEntryPointCount`</para>
            /// <para>will return the number of defined entry points.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int GetDefinedEntryPointCount();

            /// <summary>Get the name of an entry point defined in the module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetDefinedEntryPoint(int index, out global::ShaderSlang.Net.Bindings.Generated.Slang.IEntryPoint outEntryPoint);

            /// <summary>Get a serialized representation of the checked module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Serialize(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outSerializedBlob);

            /// <summary>Write the serialized representation of this module to a file.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult WriteToFile(string fileName);

            /// <summary>Get the name of the module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetName();

            /// <summary>Get the path of the module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetFilePath();

            /// <summary>Get the unique identity of the module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetUniqueIdentity();

            /// <summary>
            /// <para>Find and validate an entry point by name, even if the function is</para>
            /// <para>not marked with the `[shader(&quot;...&quot;)]` attribute.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult FindAndCheckEntryPoint(string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage, out global::ShaderSlang.Net.Bindings.Generated.Slang.IEntryPoint outEntryPoint, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            /// <summary>
            /// <para>Get the number of dependency files that this module depends on.</para>
            /// <para>This includes both the explicit source files, as well as any</para>
            /// <para>additional files that were transitively referenced (e.g., via</para>
            /// <para>a `#include` directive).</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int GetDependencyFileCount();

            /// <summary>Get the path to a file this module depends on.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetDependencyFilePath(int index);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.Slang.DeclReflection GetModuleReflection();

            /// <summary>Disassemble a module.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Disassemble(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDisassembledBlob);
        }

        [global::System.Runtime.InteropServices.GuidAttribute("8e12e8e3-5fcd-433e-afcb-13a088bc5ee5")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IModulePrecompileServiceExperimental : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult PrecompileForTarget(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetPrecompiledTargetCode(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outCode, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            long GetModuleDependencyCount();

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetModuleDependency(long dependencyIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.IModule outModule, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics);
        }

        /// <summary>Argument used for specialization to types/values.</summary>
        public unsafe partial class SpecializationArg : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.Kind kind;

                [FieldOffset(8)]
                internal __IntPtr type;

                [FieldOffset(8)]
                internal __IntPtr expr;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17SpecializationArgC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17SpecializationArg8fromTypeEPNS_14TypeReflectionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal FromType(__IntPtr inType);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang17SpecializationArg8fromExprEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal FromExpr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string inExpr);
            }

            public enum Kind
            {
                /// <summary>An invalid specialization argument. </summary>
                Unknown = 0,
                /// <summary>Specialize to a type. </summary>
                Type = 1,
                /// <summary>An expression representing a type or value </summary>
                Expr = 2
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            private bool __expr_OwnsNativeMemory = false;
            protected bool __ownsNativeInstance;

            internal static SpecializationArg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SpecializationArg(native.ToPointer(), skipVTables);
            }

            internal static SpecializationArg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SpecializationArg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SpecializationArg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SpecializationArg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SpecializationArg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SpecializationArg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SpecializationArg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public SpecializationArg(global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__Internal*) _0.__Instance);
                if (_0.__expr_OwnsNativeMemory)
                    this.Expr = _0.Expr;
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__expr_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->expr);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg FromType(global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection inType)
            {
                var __arg0 = inType is null ? __IntPtr.Zero : inType.__Instance;
                var ___ret = __Internal.FromType(__arg0);
                return global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__CreateInstance(___ret);
            }

            public static global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg FromExpr(string inExpr)
            {
                var ___ret = __Internal.FromExpr(inExpr);
                return global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.__CreateInstance(___ret);
            }

            /// <summary>The kind of specialization argument. </summary>
            public global::ShaderSlang.Net.Bindings.Generated.Slang.SpecializationArg.Kind kind
            {
                get
                {
                    return ((__Internal*)__Instance)->kind;
                }

                set
                {
                    ((__Internal*)__Instance)->kind = value;
                }
            }

            /// <summary>A type specialization argument, used for `Kind::Type`. </summary>
            public global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection Type
            {
                get
                {
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.TypeReflection.__GetOrCreateInstance(((__Internal*)__Instance)->type, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->type = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>An expression in Slang syntax, used for `Kind::Expr`. </summary>
            public string Expr
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->expr);
                }

                set
                {
                    if (__expr_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->expr);
                    __expr_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->expr = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->expr = (__IntPtr) __bytePtr0;
                }
            }
        }

        public unsafe partial class VMExecOperand : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr section;
                internal uint type;
                internal uint size;
                internal uint offset;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang13VMExecOperandC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK5slang13VMExecOperand6getPtrEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPtr(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK5slang13VMExecOperand7getTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.Generated.Slang.OperandDataType GetType(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static VMExecOperand __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VMExecOperand(native.ToPointer(), skipVTables);
            }

            internal static VMExecOperand __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VMExecOperand)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static VMExecOperand __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VMExecOperand(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VMExecOperand(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected VMExecOperand(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VMExecOperand()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public VMExecOperand(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public byte** Section
            {
                get
                {
                    return (byte**) ((__Internal*)__Instance)->section;
                }

                set
                {
                    ((__Internal*)__Instance)->section = (__IntPtr) value;
                }
            }

            public uint type
            {
                get
                {
                    return ((__Internal*)__Instance)->type;
                }

                set
                {
                    ((__Internal*)__Instance)->type = value;
                }
            }

            public uint Size
            {
                get
                {
                    return ((__Internal*)__Instance)->size;
                }

                set
                {
                    ((__Internal*)__Instance)->size = value;
                }
            }

            public uint Offset
            {
                get
                {
                    return ((__Internal*)__Instance)->offset;
                }

                set
                {
                    ((__Internal*)__Instance)->offset = value;
                }
            }

            public __IntPtr Ptr
            {
                get
                {
                    var ___ret = __Internal.GetPtr(__Instance);
                    return ___ret;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.OperandDataType Type
            {
                get
                {
                    var ___ret = __Internal.GetType(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class VMExecInstHeader : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr functionPtr;
                internal uint opcodeExtension;
                internal uint operandCount;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16VMExecInstHeaderC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZNK5slang16VMExecInstHeader10getOperandEl", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetOperand(__IntPtr __instance, long index);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16VMExecInstHeader11getNextInstEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetNextInst(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static VMExecInstHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VMExecInstHeader(native.ToPointer(), skipVTables);
            }

            internal static VMExecInstHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VMExecInstHeader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static VMExecInstHeader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VMExecInstHeader(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VMExecInstHeader(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected VMExecInstHeader(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VMExecInstHeader()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public VMExecInstHeader(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand GetOperand(long index)
            {
                var ___ret = __Internal.GetOperand(__Instance, index);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecOperand.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VMExtFunction FunctionPtr
            {
                get
                {
                    var __ptr0 = ((__Internal*)__Instance)->functionPtr;
                    return __ptr0 == IntPtr.Zero? null : (global::ShaderSlang.Net.Bindings.Generated.Slang.VMExtFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ShaderSlang.Net.Bindings.Generated.Slang.VMExtFunction));
                }

                set
                {
                    ((__Internal*)__Instance)->functionPtr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
                }
            }

            public uint OpcodeExtension
            {
                get
                {
                    return ((__Internal*)__Instance)->opcodeExtension;
                }

                set
                {
                    ((__Internal*)__Instance)->opcodeExtension = value;
                }
            }

            public uint OperandCount
            {
                get
                {
                    return ((__Internal*)__Instance)->operandCount;
                }

                set
                {
                    ((__Internal*)__Instance)->operandCount = value;
                }
            }

            public global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader NextInst
            {
                get
                {
                    var ___ret = __Internal.GetNextInst(__Instance);
                    var __result0 = global::ShaderSlang.Net.Bindings.Generated.Slang.VMExecInstHeader.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class ByteCodeFuncInfo : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal uint parameterCount;
                internal uint returnValueSize;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang16ByteCodeFuncInfoC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ByteCodeFuncInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ByteCodeFuncInfo(native.ToPointer(), skipVTables);
            }

            internal static ByteCodeFuncInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ByteCodeFuncInfo)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ByteCodeFuncInfo __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ByteCodeFuncInfo(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ByteCodeFuncInfo(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ByteCodeFuncInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ByteCodeFuncInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public ByteCodeFuncInfo(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint ParameterCount
            {
                get
                {
                    return ((__Internal*)__Instance)->parameterCount;
                }

                set
                {
                    ((__Internal*)__Instance)->parameterCount = value;
                }
            }

            public uint ReturnValueSize
            {
                get
                {
                    return ((__Internal*)__Instance)->returnValueSize;
                }

                set
                {
                    ((__Internal*)__Instance)->returnValueSize = value;
                }
            }
        }

        public unsafe partial class ByteCodeRunnerDesc : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal ulong structSize;

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18ByteCodeRunnerDescC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang18ByteCodeRunnerDescC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ByteCodeRunnerDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ByteCodeRunnerDesc(native.ToPointer(), skipVTables);
            }

            internal static ByteCodeRunnerDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ByteCodeRunnerDesc)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ByteCodeRunnerDesc __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ByteCodeRunnerDesc(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ByteCodeRunnerDesc(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ByteCodeRunnerDesc(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ByteCodeRunnerDesc()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public ByteCodeRunnerDesc(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc.__Internal*) __Instance) = *((global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeRunnerDesc.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>The size of this structure, in bytes.</summary>
            public ulong StructSize
            {
                get
                {
                    return ((__Internal*)__Instance)->structSize;
                }

                set
                {
                    ((__Internal*)__Instance)->structSize = value;
                }
            }
        }

        /// <summary>Represents a byte code runner that can execute Slang byte code.</summary>
        [global::System.Runtime.InteropServices.GuidAttribute("afdab195-361f-42cb-9513-9006261dd8cd")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface IByteCodeRunner : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            /// <summary>Load a byte code module into the execution context.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LoadModule(global::ShaderSlang.Net.Bindings.Generated.ISlangBlob moduleBlob);

            /// <summary>Select a function for execution.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SelectFunctionByIndex(uint functionIndex);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int FindFunctionByName(string name);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetFunctionInfo(uint index, out global::ShaderSlang.Net.Bindings.Generated.Slang.ByteCodeFuncInfo outInfo);

            /// <summary>Obtain the current working set memory for the selected function.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            __IntPtr GetCurrentWorkingSet();

            /// <summary>Execute the selected function.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Execute(__IntPtr argumentData, ulong argumentSize);

            /// <summary>Query the error string.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void GetErrorString(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Retrieve the return value of the last executed function.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            __IntPtr GetReturnValue(out ulong outValueSize);

            /// <summary>Set the user data for the external instruction handler.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetExtInstHandlerUserData(__IntPtr userData);

            /// <summary>Register an external function that can be called from the byte code.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult RegisterExtCall(string name, global::ShaderSlang.Net.Bindings.Generated.Slang.VMExtFunction functionPtr);

            /// <summary>Set a callback function to print messages from the byte code runner.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetPrintCallback(global::ShaderSlang.Net.Bindings.Generated.Slang.VMPrintFunc callback, __IntPtr userData);
        }

        public unsafe partial class slang
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19createGlobalSessionEPPNS_14IGlobalSessionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult CreateGlobalSession(__IntPtr outGlobalSession);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang19createGlobalSessionEPK22SlangGlobalSessionDescPPNS_14IGlobalSessionE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::ShaderSlang.Net.Bindings.SlangResult CreateGlobalSession(__IntPtr desc, __IntPtr outGlobalSession);

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang8shutdownEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Shutdown();

                [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_ZN5slang27getLastInternalErrorMessageEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetLastInternalErrorMessage();
            }

            public static global::ShaderSlang.Net.Bindings.SlangResult CreateGlobalSession(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession outGlobalSession)
            {
                var ____arg0 = outGlobalSession is null ? __IntPtr.Zero : outGlobalSession.__PointerToIGlobalSession;
                var __arg0 = new __IntPtr(&____arg0);
                var ___ret = __Internal.CreateGlobalSession(__arg0);
                return ___ret;
            }

            public static global::ShaderSlang.Net.Bindings.SlangResult CreateGlobalSession(global::ShaderSlang.Net.Bindings.Generated.SlangGlobalSessionDesc desc, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession outGlobalSession)
            {
                var __arg0 = desc is null ? __IntPtr.Zero : desc.__Instance;
                var ____arg1 = outGlobalSession is null ? __IntPtr.Zero : outGlobalSession.__PointerToIGlobalSession;
                var __arg1 = new __IntPtr(&____arg1);
                var ___ret = __Internal.CreateGlobalSession(__arg0, __arg1);
                return ___ret;
            }

            public static void Shutdown()
            {
                __Internal.Shutdown();
            }

            public static string GetLastInternalErrorMessage()
            {
                var ___ret = __Internal.GetLastInternalErrorMessage();
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }
    }

    public unsafe partial class slang_deprecated
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCreateSession", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpCreateSession([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string deprecated);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spDestroySession", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpDestroySession(__IntPtr session);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSessionSetSharedLibraryLoader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSessionSetSharedLibraryLoader(__IntPtr session, __IntPtr loader);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSessionGetSharedLibraryLoader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpSessionGetSharedLibraryLoader(__IntPtr session);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSessionCheckCompileTargetSupport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSessionCheckCompileTargetSupport(__IntPtr session, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSessionCheckPassThroughSupport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSessionCheckPassThroughSupport(__IntPtr session, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddBuiltins", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddBuiltins(__IntPtr session, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sourcePath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sourceString);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCreateCompileRequest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpCreateCompileRequest(__IntPtr session);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spDestroyCompileRequest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpDestroyCompileRequest(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetFileSystem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetFileSystem(__IntPtr request, __IntPtr fileSystem);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetCompileFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetCompileFlags(__IntPtr request, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetCompileFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpGetCompileFlags(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDumpIntermediates", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDumpIntermediates(__IntPtr request, int enable);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDumpIntermediatePrefix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDumpIntermediatePrefix(__IntPtr request, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetLineDirectiveMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetLineDirectiveMode(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetLineDirectiveMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetLineDirectiveMode(__IntPtr request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetForceGLSLScalarBufferLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetForceGLSLScalarBufferLayout(__IntPtr request, int targetIndex, bool forceScalarLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetUseMinimumSlangOptimization", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetUseMinimumSlangOptimization(__IntPtr request, int targetIndex, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetIgnoreCapabilityCheck", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetIgnoreCapabilityCheck(__IntPtr request, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetCodeGenTarget", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetCodeGenTarget(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddCodeGenTarget", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpAddCodeGenTarget(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetProfile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetProfile(__IntPtr request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangProfileID profile);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetFlags(__IntPtr request, int targetIndex, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetFloatingPointMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetFloatingPointMode(__IntPtr request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTargetCapability", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddTargetCapability(__IntPtr request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID capability);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTargetMatrixLayoutMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetTargetMatrixLayoutMode(__IntPtr request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetMatrixLayoutMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetMatrixLayoutMode(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDebugInfoLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDebugInfoLevel(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDebugInfoFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDebugInfoFormat(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoFormat format);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetOptimizationLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetOptimizationLevel(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangOptimizationLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetOutputContainerFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetOutputContainerFormat(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangContainerFormat format);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetPassThrough", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetPassThrough(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDiagnosticCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDiagnosticCallback(__IntPtr request, __IntPtr callback, __IntPtr userData);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetWriter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetWriter(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel, __IntPtr writer);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetWriter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetWriter(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddSearchPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddSearchPath(__IntPtr request, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string searchDir);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddPreprocessorDefine", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddPreprocessorDefine(__IntPtr request, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spProcessCommandLineArguments", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpProcessCommandLineArguments(__IntPtr request, sbyte** args, int argCount);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTranslationUnit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpAddTranslationUnit(__IntPtr request, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage language, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDefaultModuleName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDefaultModuleName(__IntPtr request, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string defaultModuleName);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spTranslationUnit_addPreprocessorDefine", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpTranslationUnitAddPreprocessorDefine(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTranslationUnitSourceFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddTranslationUnitSourceFile(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTranslationUnitSourceString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddTranslationUnitSourceString(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string source);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddLibraryReference", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpAddLibraryReference(__IntPtr request, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string basePath, __IntPtr libData, ulong libDataSize);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTranslationUnitSourceStringSpan", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddTranslationUnitSourceStringSpan(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sourceBegin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sourceEnd);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddTranslationUnitSourceBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpAddTranslationUnitSourceBlob(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, __IntPtr sourceBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spFindProfile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangProfileID SpFindProfile(__IntPtr session, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spFindCapability", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID SpFindCapability(__IntPtr session, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddEntryPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpAddEntryPoint(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spAddEntryPointEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpAddEntryPointEx(__IntPtr request, int translationUnitIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage, int genericArgCount, sbyte** genericArgs);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetGlobalGenericArgs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSetGlobalGenericArgs(__IntPtr request, int genericArgCount, sbyte** genericArgs);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTypeNameForGlobalExistentialTypeParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSetTypeNameForGlobalExistentialTypeParam(__IntPtr request, int slotIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string typeName);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetTypeNameForEntryPointExistentialTypeParam", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSetTypeNameForEntryPointExistentialTypeParam(__IntPtr request, int entryPointIndex, int slotIndex, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string typeName);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompile(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetDiagnosticOutput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetDiagnosticOutput(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetDiagnosticOutputBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetDiagnosticOutputBlob(__IntPtr request, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetDependencyFileCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpGetDependencyFileCount(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetDependencyFilePath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetDependencyFilePath(__IntPtr request, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetTranslationUnitCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpGetTranslationUnitCount(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetEntryPointSource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetEntryPointSource(__IntPtr request, int entryPointIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetEntryPointCode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetEntryPointCode(__IntPtr request, int entryPointIndex, ulong* outSize);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetEntryPointCodeBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetEntryPointCodeBlob(__IntPtr request, int entryPointIndex, int targetIndex, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetEntryPointHostCallable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetEntryPointHostCallable(__IntPtr request, int entryPointIndex, int targetIndex, __IntPtr outSharedLibrary);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetTargetCodeBlob", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetTargetCodeBlob(__IntPtr request, int targetIndex, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetTargetHostCallable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetTargetHostCallable(__IntPtr request, int targetIndex, __IntPtr outSharedLibrary);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetCompileRequestCode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetCompileRequestCode(__IntPtr request, ulong* outSize);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetContainerCode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetContainerCode(__IntPtr request, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spLoadRepro", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpLoadRepro(__IntPtr request, __IntPtr fileSystem, __IntPtr data, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSaveRepro", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpSaveRepro(__IntPtr request, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spEnableReproCapture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpEnableReproCapture(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetCompileTimeProfile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpGetCompileTimeProfile(__IntPtr request, __IntPtr compileTimeProfile, bool shouldClear);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spExtractRepro", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpExtractRepro(__IntPtr session, __IntPtr reproData, ulong reproDataSize, __IntPtr fileSystem);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spLoadReproAsFileSystem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpLoadReproAsFileSystem(__IntPtr session, __IntPtr reproData, ulong reproDataSize, __IntPtr replaceFileSystem, __IntPtr outFileSystem);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spOverrideDiagnosticSeverity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpOverrideDiagnosticSeverity(__IntPtr request, long messageID, global::ShaderSlang.Net.Bindings.Generated.SlangSeverity overrideSeverity);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetDiagnosticFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpGetDiagnosticFlags(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spSetDiagnosticFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpSetDiagnosticFlags(__IntPtr request, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetReflection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetReflection(__IntPtr request);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionUserAttributeGetName(__IntPtr attrib);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetArgumentCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionUserAttributeGetArgumentCount(__IntPtr attrib);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetArgumentType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionUserAttributeGetArgumentType(__IntPtr attrib, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetArgumentValueInt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpReflectionUserAttributeGetArgumentValueInt(__IntPtr attrib, uint index, int* rs);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetArgumentValueFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpReflectionUserAttributeGetArgumentValueFloat(__IntPtr attrib, uint index, float* rs);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionUserAttribute_GetArgumentValueString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionUserAttributeGetArgumentValueString(__IntPtr attrib, uint index, ulong* outSize);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetKind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangTypeKind SpReflectionTypeGetKind(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetUserAttributeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeGetUserAttributeCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetUserAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetUserAttribute(__IntPtr type, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_FindUserAttributeByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeFindUserAttributeByName(__IntPtr type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_applySpecializations", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeApplySpecializations(__IntPtr type, __IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetFieldCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeGetFieldCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetFieldByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetFieldByIndex(__IntPtr type, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetElementCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionTypeGetElementCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetSpecializedElementCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionTypeGetSpecializedElementCount(__IntPtr type, __IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetElementType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetElementType(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetRowCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeGetRowCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetColumnCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeGetColumnCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetScalarType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangScalarType SpReflectionTypeGetScalarType(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetResourceShape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape SpReflectionTypeGetResourceShape(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetResourceAccess", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess SpReflectionTypeGetResourceAccess(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetResourceResultType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetResourceResultType(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetName(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetFullName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpReflectionTypeGetFullName(__IntPtr type, __IntPtr outNameBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_GetGenericContainer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetGenericContainer(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetType(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getKind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangTypeKind SpReflectionTypeLayoutGetKind(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionTypeLayoutGetSize(__IntPtr type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetStride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionTypeLayoutGetStride(__IntPtr type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getAlignment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpReflectionTypeLayoutGetAlignment(__IntPtr type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetFieldCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeLayoutGetFieldCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetFieldByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetFieldByIndex(__IntPtr type, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_findFieldIndexByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutFindFieldIndexByName(__IntPtr typeLayout, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string nameBegin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string nameEnd);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetExplicitCounter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetExplicitCounter(__IntPtr typeLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetElementStride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionTypeLayoutGetElementStride(__IntPtr type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetElementTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetElementTypeLayout(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetElementVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetElementVarLayout(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getContainerVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetContainerVarLayout(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetParameterCategory", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetParameterCategory(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetCategoryCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeLayoutGetCategoryCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetCategoryByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetCategoryByIndex(__IntPtr type, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_GetMatrixLayoutMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode SpReflectionTypeLayoutGetMatrixLayoutMode(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getGenericParamIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpReflectionTypeLayoutGetGenericParamIndex(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getPendingDataTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetPendingDataTypeLayout(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetSpecializedTypePendingDataVarLayout(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_getSpecializedTypeArgCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeGetSpecializedTypeArgCount(__IntPtr type);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionType_getSpecializedTypeArgType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeGetSpecializedTypeArgType(__IntPtr type, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetBindingRangeCount(__IntPtr typeLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangBindingType SpReflectionTypeLayoutGetBindingRangeType(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_isBindingRangeSpecializable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutIsBindingRangeSpecializable(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeBindingCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetBindingRangeBindingCount(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeLeafTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetBindingRangeLeafTypeLayout(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeLeafVariable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetBindingRangeLeafVariable(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeImageFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat SpReflectionTypeLayoutGetBindingRangeImageFormat(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getFieldBindingRangeOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetFieldBindingRangeOffset(__IntPtr typeLayout, long fieldIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getExplicitCounterBindingRangeOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetExplicitCounterBindingRangeOffset(__IntPtr inTypeLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeDescriptorSetIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetBindingRangeDescriptorSetIndex(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetBindingRangeFirstDescriptorRangeIndex(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getBindingRangeDescriptorRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetBindingRangeDescriptorRangeCount(__IntPtr typeLayout, long index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetDescriptorSetCount(__IntPtr typeLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetSpaceOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetDescriptorSetSpaceOffset(__IntPtr typeLayout, long setIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCount(__IntPtr typeLayout, long setIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeIndexOffset(__IntPtr typeLayout, long setIndex, long rangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeDescriptorCount(__IntPtr typeLayout, long setIndex, long rangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetDescriptorRangeType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangBindingType SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeType(__IntPtr typeLayout, long setIndex, long rangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCategory(__IntPtr typeLayout, long setIndex, long rangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getSubObjectRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetSubObjectRangeCount(__IntPtr typeLayout);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetSubObjectRangeBindingRangeIndex(__IntPtr typeLayout, long subObjectRangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getSubObjectRangeSpaceOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionTypeLayoutGetSubObjectRangeSpaceOffset(__IntPtr typeLayout, long subObjectRangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeLayout_getSubObjectRangeOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeLayoutGetSubObjectRangeOffset(__IntPtr typeLayout, long subObjectRangeIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableGetName(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableGetType(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_FindModifier", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableFindModifier(__IntPtr var, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetUserAttributeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionVariableGetUserAttributeCount(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetUserAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableGetUserAttribute(__IntPtr var, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_FindUserAttributeByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableFindUserAttributeByName(__IntPtr var, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_HasDefaultValue", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SpReflectionVariableHasDefaultValue(__IntPtr inVar);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetDefaultValueInt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpReflectionVariableGetDefaultValueInt(__IntPtr inVar, long* rs);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_GetGenericContainer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableGetGenericContainer(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariable_applySpecializations", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableApplySpecializations(__IntPtr var, __IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetVariable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableLayoutGetVariable(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableLayoutGetTypeLayout(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetOffset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionVariableLayoutGetOffset(__IntPtr var, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetSpace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionVariableLayoutGetSpace(__IntPtr var, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetImageFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat SpReflectionVariableLayoutGetImageFormat(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetSemanticName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableLayoutGetSemanticName(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_GetSemanticIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionVariableLayoutGetSemanticIndex(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_asDecl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionAsDecl(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetName(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_FindModifier", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionFindModifier(__IntPtr var, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetUserAttributeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionFunctionGetUserAttributeCount(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetUserAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetUserAttribute(__IntPtr func, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_FindUserAttributeByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionFindUserAttributeByName(__IntPtr func, __IntPtr globalSession, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionFunctionGetParameterCount(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetParameter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetParameter(__IntPtr func, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetResultType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetResultType(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_GetGenericContainer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetGenericContainer(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_applySpecializations", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionApplySpecializations(__IntPtr func, __IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_specializeWithArgTypes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionSpecializeWithArgTypes(__IntPtr func, long argTypeCount, __IntPtr argTypes);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_isOverloaded", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SpReflectionFunctionIsOverloaded(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_getOverloadCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionFunctionGetOverloadCount(__IntPtr func);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionFunction_getOverload", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFunctionGetOverload(__IntPtr func, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_getChildrenCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionDeclGetChildrenCount(__IntPtr parentDecl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_getChild", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclGetChild(__IntPtr parentDecl, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_getName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclGetName(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_getKind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind SpReflectionDeclGetKind(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_castToFunction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclCastToFunction(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_castToVariable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclCastToVariable(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_castToGeneric", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclCastToGeneric(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getTypeFromDecl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetTypeFromDecl(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_getParent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclGetParent(__IntPtr decl);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionDecl_findModifier", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionDeclFindModifier(__IntPtr decl, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_asDecl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericAsDecl(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetName(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetTypeParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionGenericGetTypeParameterCount(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetTypeParameter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetTypeParameter(__IntPtr generic, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetValueParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionGenericGetValueParameterCount(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetValueParameter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetValueParameter(__IntPtr generic, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetTypeParameterConstraintCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionGenericGetTypeParameterConstraintCount(__IntPtr generic, __IntPtr typeParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetTypeParameterConstraintType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetTypeParameterConstraintType(__IntPtr generic, __IntPtr typeParam, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetInnerKind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind SpReflectionGenericGetInnerKind(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetInnerDecl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetInnerDecl(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetOuterGenericContainer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetOuterGenericContainer(__IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetConcreteType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericGetConcreteType(__IntPtr generic, __IntPtr typeParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_GetConcreteIntVal", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long SpReflectionGenericGetConcreteIntVal(__IntPtr generic, __IntPtr valueParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionGeneric_applySpecializations", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGenericApplySpecializations(__IntPtr currGeneric, __IntPtr generic);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_getStage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangStage SpReflectionVariableLayoutGetStage(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionVariableLayout_getPendingDataLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionVariableLayoutGetPendingDataLayout(__IntPtr var);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionParameter_GetBindingIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionParameterGetBindingIndex(__IntPtr parameter);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionParameter_GetBindingSpace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionParameterGetBindingSpace(__IntPtr parameter);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spIsParameterLocationUsed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpIsParameterLocationUsed(__IntPtr request, long entryPointIndex, long targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category, ulong spaceIndex, ulong registerIndex, bool* outUsed);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetName(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getNameOverride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetNameOverride(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getFunction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetFunction(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionEntryPointGetParameterCount(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getParameterByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetParameterByIndex(__IntPtr entryPoint, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getStage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.Generated.SlangStage SpReflectionEntryPointGetStage(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getComputeThreadGroupSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpReflectionEntryPointGetComputeThreadGroupSize(__IntPtr entryPoint, ulong axisCount, ulong* outSizeAlongAxis);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getComputeWaveSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SpReflectionEntryPointGetComputeWaveSize(__IntPtr entryPoint, ulong* outWaveSize);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_usesAnySampleRateInput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpReflectionEntryPointUsesAnySampleRateInput(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetVarLayout(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_getResultVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionEntryPointGetResultVarLayout(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionEntryPoint_hasDefaultConstantBuffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SpReflectionEntryPointHasDefaultConstantBuffer(__IntPtr entryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeParameter_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeParameterGetName(__IntPtr typeParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeParameter_GetIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeParameterGetIndex(__IntPtr typeParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeParameter_GetConstraintCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionTypeParameterGetConstraintCount(__IntPtr typeParam);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflectionTypeParameter_GetConstraintByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTypeParameterGetConstraintByIndex(__IntPtr typeParam, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_ToJson", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpReflectionToJson(__IntPtr reflection, __IntPtr request, __IntPtr outBlob);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_GetParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionGetParameterCount(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_GetParameterByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetParameterByIndex(__IntPtr reflection, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_GetTypeParameterCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpReflectionGetTypeParameterCount(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_GetTypeParameterByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetTypeParameterByIndex(__IntPtr reflection, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_FindTypeParameter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindTypeParameter(__IntPtr reflection, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_FindTypeByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindTypeByName(__IntPtr reflection, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_GetTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetTypeLayout(__IntPtr reflection, __IntPtr reflectionType, global::ShaderSlang.Net.Bindings.Generated.SlangLayoutRules rules);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_FindFunctionByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindFunctionByName(__IntPtr reflection, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_FindFunctionByNameInType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindFunctionByNameInType(__IntPtr reflection, __IntPtr reflType, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_FindVarByNameInType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindVarByNameInType(__IntPtr reflection, __IntPtr reflType, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_TryResolveOverloadedFunction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionTryResolveOverloadedFunction(__IntPtr reflection, uint candidateCount, __IntPtr candidates);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getEntryPointCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionGetEntryPointCount(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getEntryPointByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetEntryPointByIndex(__IntPtr reflection, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_findEntryPointByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionFindEntryPointByName(__IntPtr reflection, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getGlobalConstantBufferBinding", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionGetGlobalConstantBufferBinding(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getGlobalConstantBufferSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionGetGlobalConstantBufferSize(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_specializeType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionSpecializeType(__IntPtr reflection, __IntPtr type, long specializationArgCount, __IntPtr specializationArgs, __IntPtr outDiagnostics);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_specializeGeneric", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionSpecializeGeneric(__IntPtr inProgramLayout, __IntPtr generic, long argCount, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType* argTypes, __IntPtr args, __IntPtr outDiagnostics);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_isSubType", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SpReflectionIsSubType(__IntPtr reflection, __IntPtr subType, __IntPtr superType);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getHashedStringCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SpReflectionGetHashedStringCount(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getHashedString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetHashedString(__IntPtr reflection, ulong index, ulong* outCount);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spComputeStringHash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SpComputeStringHash([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string chars, ulong count);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getGlobalParamsTypeLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetGlobalParamsTypeLayout(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spReflection_getGlobalParamsVarLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetGlobalParamsVarLayout(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spGetTranslationUnitSource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpGetTranslationUnitSource(__IntPtr request, int translationUnitIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "_Z23spReflection_GetSessionP18SlangProgramLayout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SpReflectionGetSession(__IntPtr reflection);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompileRequest_getProgram", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetProgram(__IntPtr request, __IntPtr outProgram);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompileRequest_getProgramWithEntryPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetProgramWithEntryPoints(__IntPtr request, __IntPtr outProgram);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompileRequest_getEntryPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetEntryPoint(__IntPtr request, long entryPointIndex, __IntPtr outEntryPoint);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompileRequest_getModule", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetModule(__IntPtr request, long translationUnitIndex, __IntPtr outModule);

            [SuppressUnmanagedCodeSecurity, DllImport("slang-compiler", EntryPoint = "spCompileRequest_getSession", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetSession(__IntPtr request, __IntPtr outSession);
        }

        /// <summary>Initialize an instance of the Slang library.</summary>
        public static global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession SpCreateSession(string deprecated)
        {
            var ___ret = __Internal.SpCreateSession(deprecated);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>Clean up after an instance of the Slang library.</summary>
        public static void SpDestroySession(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            __Internal.SpDestroySession(__arg0);
        }

        /// <remarks>slang::IGlobalSession::setSharedLibraryLoader</remarks>
        public static void SpSessionSetSharedLibraryLoader(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibraryLoader loader)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var __arg1 = loader is null ? __IntPtr.Zero : loader.__PointerToISlangSharedLibraryLoader;
            __Internal.SpSessionSetSharedLibraryLoader(__arg0, __arg1);
        }

        /// <remarks>slang::IGlobalSession::getSharedLibraryLoader</remarks>
        public static global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibraryLoader SpSessionGetSharedLibraryLoader(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpSessionGetSharedLibraryLoader(__arg0);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibraryLoader.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <remarks>slang::IGlobalSession::checkCompileTargetSupport</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSessionCheckCompileTargetSupport(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpSessionCheckCompileTargetSupport(__arg0, target);
            return ___ret;
        }

        /// <remarks>slang::IGlobalSession::checkPassThroughSupport</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSessionCheckPassThroughSupport(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpSessionCheckPassThroughSupport(__arg0, passThrough);
            return ___ret;
        }

        /// <remarks>slang::IGlobalSession::addBuiltins</remarks>
        public static void SpAddBuiltins(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, string sourcePath, string sourceString)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            __Internal.SpAddBuiltins(__arg0, sourcePath, sourceString);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest SpCreateCompileRequest(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpCreateCompileRequest(__arg0);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <summary>
        /// <para>Destroy a compile request.</para>
        /// <para>Note a request is a COM object and can be destroyed via 'Release'.</para>
        /// </summary>
        public static void SpDestroyCompileRequest(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpDestroyCompileRequest(__arg0);
        }

        /// <remarks>slang::ICompileRequest::setFileSystem </remarks>
        public static void SpSetFileSystem(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem fileSystem)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg1 = fileSystem is null ? __IntPtr.Zero : fileSystem.__PointerToISlangFileSystem;
            __Internal.SpSetFileSystem(__arg0, __arg1);
        }

        /// <remarks>slang::ICompileRequest::setCompileFlags </remarks>
        public static void SpSetCompileFlags(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, uint flags)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetCompileFlags(__arg0, flags);
        }

        /// <remarks>slang::ICompileRequest::getCompileFlags </remarks>
        public static uint SpGetCompileFlags(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetCompileFlags(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setDumpIntermediates </remarks>
        public static void SpSetDumpIntermediates(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int enable)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDumpIntermediates(__arg0, enable);
        }

        /// <remarks>slang::ICompileRequest::setDumpIntermediatePrefix </remarks>
        public static void SpSetDumpIntermediatePrefix(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, string prefix)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDumpIntermediatePrefix(__arg0, prefix);
        }

        /// <summary>DEPRECATED: use `spSetTargetLineDirectiveMode` instead.</summary>
        /// <remarks>slang::ICompileRequest::setLineDirectiveMode </remarks>
        public static void SpSetLineDirectiveMode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetLineDirectiveMode(__arg0, mode);
        }

        /// <remarks>slang::ICompileRequest::setTargetLineDirectiveMode </remarks>
        public static void SpSetTargetLineDirectiveMode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetLineDirectiveMode(__arg0, targetIndex, mode);
        }

        /// <remarks>slang::ICompileRequest::setTargetLineDirectiveMode </remarks>
        public static void SpSetTargetForceGLSLScalarBufferLayout(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, bool forceScalarLayout)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetForceGLSLScalarBufferLayout(__arg0, targetIndex, forceScalarLayout);
        }

        /// <remarks>slang::ICompileRequest::setTargetUseMinimumSlangOptimization </remarks>
        public static void SpSetTargetUseMinimumSlangOptimization(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, bool val)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetUseMinimumSlangOptimization(__arg0, targetIndex, val);
        }

        /// <remarks>slang::ICompileRequest::setIgnoreCapabilityCheck </remarks>
        public static void SpSetIgnoreCapabilityCheck(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, bool val)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetIgnoreCapabilityCheck(__arg0, val);
        }

        /// <remarks>slang::ICompileRequest::setCodeGenTarget </remarks>
        public static void SpSetCodeGenTarget(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetCodeGenTarget(__arg0, target);
        }

        /// <remarks>slang::ICompileRequest::addCodeGenTarget </remarks>
        public static int SpAddCodeGenTarget(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpAddCodeGenTarget(__arg0, target);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setTargetProfile </remarks>
        public static void SpSetTargetProfile(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangProfileID profile)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetProfile(__arg0, targetIndex, profile);
        }

        /// <remarks>slang::ICompileRequest::setTargetFlags </remarks>
        public static void SpSetTargetFlags(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, uint flags)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetFlags(__arg0, targetIndex, flags);
        }

        /// <remarks>slang::ICompileRequest::setTargetFloatingPointMode </remarks>
        public static void SpSetTargetFloatingPointMode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode mode)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetFloatingPointMode(__arg0, targetIndex, mode);
        }

        /// <remarks>slang::ICompileRequest::addTargetCapability </remarks>
        public static void SpAddTargetCapability(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID capability)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddTargetCapability(__arg0, targetIndex, capability);
        }

        public static void SpSetTargetMatrixLayoutMode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetTargetMatrixLayoutMode(__arg0, targetIndex, mode);
        }

        /// <remarks>slang::ICompileRequest::setMatrixLayoutMode </remarks>
        public static void SpSetMatrixLayoutMode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetMatrixLayoutMode(__arg0, mode);
        }

        /// <remarks>slang::ICompileRequest::setDebugInfoLevel </remarks>
        public static void SpSetDebugInfoLevel(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoLevel level)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDebugInfoLevel(__arg0, level);
        }

        /// <remarks>slang::ICompileRequest::setDebugInfoFormat </remarks>
        public static void SpSetDebugInfoFormat(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoFormat format)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDebugInfoFormat(__arg0, format);
        }

        /// <remarks>slang::ICompileRequest::setOptimizationLevel </remarks>
        public static void SpSetOptimizationLevel(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangOptimizationLevel level)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetOptimizationLevel(__arg0, level);
        }

        /// <remarks>slang::ICompileRequest::setOutputContainerFormat </remarks>
        public static void SpSetOutputContainerFormat(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangContainerFormat format)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetOutputContainerFormat(__arg0, format);
        }

        /// <remarks>slang::ICompileRequest::setPassThrough </remarks>
        public static void SpSetPassThrough(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetPassThrough(__arg0, passThrough);
        }

        /// <remarks>slang::ICompileRequest::setDiagnosticCallback </remarks>
        public static void SpSetDiagnosticCallback(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangDiagnosticCallback callback, __IntPtr userData)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SpSetDiagnosticCallback(__arg0, __arg1, userData);
        }

        /// <remarks>slang::ICompileRequest::setWriter </remarks>
        public static void SpSetWriter(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel, global::ShaderSlang.Net.Bindings.Generated.ISlangWriter writer)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg2 = writer is null ? __IntPtr.Zero : writer.__PointerToISlangWriter;
            __Internal.SpSetWriter(__arg0, channel, __arg2);
        }

        /// <remarks>slang::ICompileRequest::getWriter </remarks>
        public static global::ShaderSlang.Net.Bindings.Generated.ISlangWriter SpGetWriter(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetWriter(__arg0, channel);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.ISlangWriter.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <remarks>slang::ICompileRequest::addSearchPath </remarks>
        public static void SpAddSearchPath(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, string searchDir)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddSearchPath(__arg0, searchDir);
        }

        /// <remarks>slang::ICompileRequest::addPreprocessorDefine </remarks>
        public static void SpAddPreprocessorDefine(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, string key, string value)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddPreprocessorDefine(__arg0, key, value);
        }

        /// <remarks>slang::ICompileRequest::processCommandLineArguments </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpProcessCommandLineArguments(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, char** args, int argCount)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg1 = (sbyte**) &args;
            var ___ret = __Internal.SpProcessCommandLineArguments(__arg0, __arg1, argCount);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::addTranslationUnit </remarks>
        public static int SpAddTranslationUnit(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage language, string name)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpAddTranslationUnit(__arg0, language, name);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setDefaultModuleName </remarks>
        public static void SpSetDefaultModuleName(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, string defaultModuleName)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDefaultModuleName(__arg0, defaultModuleName);
        }

        /// <remarks>slang::ICompileRequest::addPreprocessorDefine </remarks>
        public static void SpTranslationUnitAddPreprocessorDefine(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string key, string value)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpTranslationUnitAddPreprocessorDefine(__arg0, translationUnitIndex, key, value);
        }

        /// <remarks>slang::ICompileRequest::addTranslationUnitSourceFile </remarks>
        public static void SpAddTranslationUnitSourceFile(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string path)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddTranslationUnitSourceFile(__arg0, translationUnitIndex, path);
        }

        /// <remarks>slang::ICompileRequest::addTranslationUnitSourceString </remarks>
        public static void SpAddTranslationUnitSourceString(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string path, string source)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddTranslationUnitSourceString(__arg0, translationUnitIndex, path, source);
        }

        /// <remarks>slang::ICompileRequest::addLibraryReference </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpAddLibraryReference(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, string basePath, __IntPtr libData, ulong libDataSize)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpAddLibraryReference(__arg0, basePath, libData, libDataSize);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::addTranslationUnitSourceStringSpan </remarks>
        public static void SpAddTranslationUnitSourceStringSpan(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string path, string sourceBegin, string sourceEnd)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpAddTranslationUnitSourceStringSpan(__arg0, translationUnitIndex, path, sourceBegin, sourceEnd);
        }

        /// <remarks>slang::ICompileRequest::addTranslationUnitSourceBlob </remarks>
        public static void SpAddTranslationUnitSourceBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob sourceBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg3 = sourceBlob is null ? __IntPtr.Zero : sourceBlob.__PointerToISlangBlob;
            __Internal.SpAddTranslationUnitSourceBlob(__arg0, translationUnitIndex, path, __arg3);
        }

        /// <remarks>slang::IGlobalSession::findProfile </remarks>
        public static global::ShaderSlang.Net.Bindings.Generated.SlangProfileID SpFindProfile(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, string name)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpFindProfile(__arg0, name);
            return ___ret;
        }

        /// <remarks>slang::IGlobalSession::findCapability </remarks>
        public static global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID SpFindCapability(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, string name)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var ___ret = __Internal.SpFindCapability(__arg0, name);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::addEntryPoint </remarks>
        public static int SpAddEntryPoint(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpAddEntryPoint(__arg0, translationUnitIndex, name, stage);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::addEntryPointEx </remarks>
        public static int SpAddEntryPointEx(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex, string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage, int genericArgCount, char** genericArgs)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg5 = (sbyte**) &genericArgs;
            var ___ret = __Internal.SpAddEntryPointEx(__arg0, translationUnitIndex, name, stage, genericArgCount, __arg5);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setGlobalGenericArgs </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSetGlobalGenericArgs(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int genericArgCount, char** genericArgs)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg2 = (sbyte**) &genericArgs;
            var ___ret = __Internal.SpSetGlobalGenericArgs(__arg0, genericArgCount, __arg2);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSetTypeNameForGlobalExistentialTypeParam(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int slotIndex, string typeName)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpSetTypeNameForGlobalExistentialTypeParam(__arg0, slotIndex, typeName);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSetTypeNameForEntryPointExistentialTypeParam(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int entryPointIndex, int slotIndex, string typeName)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpSetTypeNameForEntryPointExistentialTypeParam(__arg0, entryPointIndex, slotIndex, typeName);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::compile </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompile(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpCompile(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getDiagnosticOutput </remarks>
        public static string SpGetDiagnosticOutput(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetDiagnosticOutput(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <remarks>slang::ICompileRequest::getDiagnosticOutputBlob </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetDiagnosticOutputBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpGetDiagnosticOutputBlob(__arg0, __arg1);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getDependencyFileCount </remarks>
        public static int SpGetDependencyFileCount(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetDependencyFileCount(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getDependencyFilePath </remarks>
        public static string SpGetDependencyFilePath(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int index)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetDependencyFilePath(__arg0, index);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <remarks>slang::ICompileRequest::getTranslationUnitCount </remarks>
        public static int SpGetTranslationUnitCount(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetTranslationUnitCount(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getEntryPointSource </remarks>
        public static string SpGetEntryPointSource(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int entryPointIndex)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetEntryPointSource(__arg0, entryPointIndex);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <remarks>slang::ICompileRequest::getEntryPointCode </remarks>
        public static __IntPtr SpGetEntryPointCode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int entryPointIndex, ref ulong outSize)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            fixed (ulong* __outSize2 = &outSize)
            {
                var __arg2 = __outSize2;
                var ___ret = __Internal.SpGetEntryPointCode(__arg0, entryPointIndex, __arg2);
                return ___ret;
            }
        }

        /// <remarks>slang::ICompileRequest::getEntryPointCodeBlob </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetEntryPointCodeBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int entryPointIndex, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg3 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg3 = new __IntPtr(&____arg3);
            var ___ret = __Internal.SpGetEntryPointCodeBlob(__arg0, entryPointIndex, targetIndex, __arg3);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getEntryPointHostCallable </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetEntryPointHostCallable(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int entryPointIndex, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary outSharedLibrary)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg3 = outSharedLibrary is null ? __IntPtr.Zero : outSharedLibrary.__PointerToISlangSharedLibrary;
            var __arg3 = new __IntPtr(&____arg3);
            var ___ret = __Internal.SpGetEntryPointHostCallable(__arg0, entryPointIndex, targetIndex, __arg3);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getTargetCodeBlob </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetTargetCodeBlob(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg2 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpGetTargetCodeBlob(__arg0, targetIndex, __arg2);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getTargetHostCallable </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetTargetHostCallable(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int targetIndex, global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary outSharedLibrary)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg2 = outSharedLibrary is null ? __IntPtr.Zero : outSharedLibrary.__PointerToISlangSharedLibrary;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpGetTargetHostCallable(__arg0, targetIndex, __arg2);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getCompileRequestCode </remarks>
        public static __IntPtr SpGetCompileRequestCode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, ref ulong outSize)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            fixed (ulong* __outSize1 = &outSize)
            {
                var __arg1 = __outSize1;
                var ___ret = __Internal.SpGetCompileRequestCode(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <remarks>slang::ICompileRequest::getContainerCode </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetContainerCode(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpGetContainerCode(__arg0, __arg1);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::loadRepro </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpLoadRepro(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem fileSystem, __IntPtr data, ulong size)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var __arg1 = fileSystem is null ? __IntPtr.Zero : fileSystem.__PointerToISlangFileSystem;
            var ___ret = __Internal.SpLoadRepro(__arg0, __arg1, data, size);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::saveRepro </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpSaveRepro(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpSaveRepro(__arg0, __arg1);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::enableReproCapture </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpEnableReproCapture(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpEnableReproCapture(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getCompileTimeProfile </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpGetCompileTimeProfile(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangProfiler compileTimeProfile, bool shouldClear)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = compileTimeProfile is null ? __IntPtr.Zero : compileTimeProfile.__PointerToISlangProfiler;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpGetCompileTimeProfile(__arg0, __arg1, shouldClear);
            return ___ret;
        }

        /// <summary>Extract contents of a repro.</summary>
        /// <param name="session">The slang session</param>
        /// <param name="reproData">Holds the repro data</param>
        /// <param name="reproDataSize">The size of the repro data</param>
        /// <param name="fileSystem">File system that the contents of the repro will be written to</param>
        /// <remarks>
        /// <para>Writes the contained files and manifest with their 'unique' names into fileSystem. For more</para>
        /// <para>details read the docs/repro.md documentation.</para>
        /// <para>A `SlangResult` to indicate success or failure.</para>
        /// </remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpExtractRepro(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, __IntPtr reproData, ulong reproDataSize, global::ShaderSlang.Net.Bindings.Generated.ISlangMutableFileSystem fileSystem)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var __arg3 = fileSystem is null ? __IntPtr.Zero : fileSystem.__PointerToISlangMutableFileSystem;
            var ___ret = __Internal.SpExtractRepro(__arg0, reproData, reproDataSize, __arg3);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpLoadReproAsFileSystem(global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession session, __IntPtr reproData, ulong reproDataSize, global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem replaceFileSystem, global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystemExt outFileSystem)
        {
            var __arg0 = session is null ? __IntPtr.Zero : session.__PointerToIGlobalSession;
            var __arg3 = replaceFileSystem is null ? __IntPtr.Zero : replaceFileSystem.__PointerToISlangFileSystem;
            var ____arg4 = outFileSystem is null ? __IntPtr.Zero : outFileSystem.__PointerToISlangFileSystemExt;
            var __arg4 = new __IntPtr(&____arg4);
            var ___ret = __Internal.SpLoadReproAsFileSystem(__arg0, reproData, reproDataSize, __arg3, __arg4);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::overrideDiagnosticSeverity </remarks>
        public static void SpOverrideDiagnosticSeverity(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, long messageID, global::ShaderSlang.Net.Bindings.Generated.SlangSeverity overrideSeverity)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpOverrideDiagnosticSeverity(__arg0, messageID, overrideSeverity);
        }

        /// <remarks>slang::ICompileRequest::getDiagnosticFlags </remarks>
        public static int SpGetDiagnosticFlags(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetDiagnosticFlags(__arg0);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::setDiagnosticFlags </remarks>
        public static void SpSetDiagnosticFlags(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int flags)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            __Internal.SpSetDiagnosticFlags(__arg0, flags);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout SpGetReflection(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetReflection(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionUserAttributeGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            var ___ret = __Internal.SpReflectionUserAttributeGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static uint SpReflectionUserAttributeGetArgumentCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            var ___ret = __Internal.SpReflectionUserAttributeGetArgumentCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionUserAttributeGetArgumentType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib, uint index)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            var ___ret = __Internal.SpReflectionUserAttributeGetArgumentType(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpReflectionUserAttributeGetArgumentValueInt(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib, uint index, ref int rs)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            fixed (int* __rs2 = &rs)
            {
                var __arg2 = __rs2;
                var ___ret = __Internal.SpReflectionUserAttributeGetArgumentValueInt(__arg0, index, __arg2);
                return ___ret;
            }
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpReflectionUserAttributeGetArgumentValueFloat(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib, uint index, ref float rs)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            fixed (float* __rs2 = &rs)
            {
                var __arg2 = __rs2;
                var ___ret = __Internal.SpReflectionUserAttributeGetArgumentValueFloat(__arg0, index, __arg2);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Returns the string-typed value of a user attribute argument</para>
        /// <para>The string returned is not null-terminated. The length of the string is returned via</para>
        /// <para>`outSize`. If index of out of range, or if the specified argument is not a string, the</para>
        /// <para>function will return nullptr.</para>
        /// </summary>
        public static string SpReflectionUserAttributeGetArgumentValueString(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute attrib, uint index, ref ulong outSize)
        {
            var __arg0 = attrib is null ? __IntPtr.Zero : attrib.__Instance;
            fixed (ulong* __outSize2 = &outSize)
            {
                var __arg2 = __outSize2;
                var ___ret = __Internal.SpReflectionUserAttributeGetArgumentValueString(__arg0, index, __arg2);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangTypeKind SpReflectionTypeGetKind(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetKind(__arg0);
            return ___ret;
        }

        public static uint SpReflectionTypeGetUserAttributeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetUserAttributeCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionTypeGetUserAttribute(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, uint index)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetUserAttribute(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionTypeFindUserAttributeByName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, string name)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeFindUserAttributeByName(__arg0, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var __arg1 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionTypeApplySpecializations(__arg0, __arg1);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionTypeGetFieldCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetFieldCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionTypeGetFieldByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, uint index)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetFieldByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the number of elements in the given type.</summary>
        /// <remarks>
        /// <para>This operation is valid for vector and array types. For other types it returns zero.</para>
        /// <para>When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,</para>
        /// <para>which is defined to be `~size_t(0)`.</para>
        /// <para>If the size of a type cannot be statically computed, perhaps because it depends on</para>
        /// <para>a generic parameter that has not been bound to a specific value, this function returns zero.</para>
        /// <para>Use spReflectionType_GetSpecializedElementCount if the size is dependent on</para>
        /// <para>a link time constant</para>
        /// </remarks>
        public static ulong SpReflectionTypeGetElementCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetElementCount(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>The same as spReflectionType_GetElementCount except it takes into account specialization</para>
        /// <para>information from the given reflection info</para>
        /// </summary>
        public static ulong SpReflectionTypeGetSpecializedElementCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var __arg1 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetSpecializedElementCount(__arg0, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeGetElementType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetElementType(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionTypeGetRowCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetRowCount(__arg0);
            return ___ret;
        }

        public static uint SpReflectionTypeGetColumnCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetColumnCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangScalarType SpReflectionTypeGetScalarType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetScalarType(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangResourceShape SpReflectionTypeGetResourceShape(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetResourceShape(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangResourceAccess SpReflectionTypeGetResourceAccess(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetResourceAccess(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeGetResourceResultType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetResourceResultType(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionTypeGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpReflectionTypeGetFullName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outNameBlob)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ____arg1 = outNameBlob is null ? __IntPtr.Zero : outNameBlob.__PointerToISlangBlob;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpReflectionTypeGetFullName(__arg0, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionTypeGetGenericContainer(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetGenericContainer(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeLayoutGetType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetType(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangTypeKind SpReflectionTypeLayoutGetKind(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetKind(__arg0);
            return ___ret;
        }

        /// <summary>Get the size of a type layout in the specified parameter category.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources (e.g., unsized arrays).</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the size depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionTypeLayoutGetSize(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSize(__arg0, category);
            return ___ret;
        }

        /// <summary>Get the stride of a type layout in the specified parameter category.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when stride depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionTypeLayoutGetStride(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetStride(__arg0, category);
            return ___ret;
        }

        public static int SpReflectionTypeLayoutGetAlignment(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetAlignment(__arg0, category);
            return ___ret;
        }

        public static uint SpReflectionTypeLayoutGetFieldCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetFieldCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetFieldByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, uint index)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetFieldByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static long SpReflectionTypeLayoutFindFieldIndexByName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, string nameBegin, string nameEnd)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutFindFieldIndexByName(__arg0, nameBegin, nameEnd);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetExplicitCounter(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetExplicitCounter(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the stride between elements of an array type layout.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when element stride depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionTypeLayoutGetElementStride(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetElementStride(__arg0, category);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionTypeLayoutGetElementTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetElementTypeLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetElementVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetElementVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetContainerVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetContainerVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetParameterCategory(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetParameterCategory(__arg0);
            return ___ret;
        }

        public static uint SpReflectionTypeLayoutGetCategoryCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetCategoryCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetCategoryByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type, uint index)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetCategoryByIndex(__arg0, index);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode SpReflectionTypeLayoutGetMatrixLayoutMode(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetMatrixLayoutMode(__arg0);
            return ___ret;
        }

        public static int SpReflectionTypeLayoutGetGenericParamIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetGenericParamIndex(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionTypeLayoutGetPendingDataTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetPendingDataTypeLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetSpecializedTypePendingDataVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSpecializedTypePendingDataVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static long SpReflectionTypeGetSpecializedTypeArgCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetSpecializedTypeArgCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeGetSpecializedTypeArgType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, long index)
        {
            var __arg0 = type is null ? __IntPtr.Zero : type.__Instance;
            var ___ret = __Internal.SpReflectionTypeGetSpecializedTypeArgType(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static long SpReflectionTypeLayoutGetBindingRangeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangBindingType SpReflectionTypeLayoutGetBindingRangeType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeType(__arg0, index);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutIsBindingRangeSpecializable(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutIsBindingRangeSpecializable(__arg0, index);
            return ___ret;
        }

        /// <summary>Get the binding count for a binding range at the specified index.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the count depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static long SpReflectionTypeLayoutGetBindingRangeBindingCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeBindingCount(__arg0, index);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionTypeLayoutGetBindingRangeLeafTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeLeafTypeLayout(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionTypeLayoutGetBindingRangeLeafVariable(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeLeafVariable(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat SpReflectionTypeLayoutGetBindingRangeImageFormat(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeImageFormat(__arg0, index);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetFieldBindingRangeOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long fieldIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetFieldBindingRangeOffset(__arg0, fieldIndex);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetExplicitCounterBindingRangeOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout inTypeLayout)
        {
            var __arg0 = inTypeLayout is null ? __IntPtr.Zero : inTypeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetExplicitCounterBindingRangeOffset(__arg0);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetBindingRangeDescriptorSetIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeDescriptorSetIndex(__arg0, index);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetBindingRangeFirstDescriptorRangeIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeFirstDescriptorRangeIndex(__arg0, index);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetBindingRangeDescriptorRangeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long index)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetBindingRangeDescriptorRangeCount(__arg0, index);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetDescriptorSetCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetCount(__arg0);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetDescriptorSetSpaceOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetSpaceOffset(__arg0, setIndex);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCount(__arg0, setIndex);
            return ___ret;
        }

        /// <summary>Get the index offset for a descriptor range within a descriptor set.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeIndexOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex, long rangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeIndexOffset(__arg0, setIndex, rangeIndex);
            return ___ret;
        }

        /// <summary>Get the descriptor count for a descriptor range within a descriptor set.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the count depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static long SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeDescriptorCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex, long rangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeDescriptorCount(__arg0, setIndex, rangeIndex);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangBindingType SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex, long rangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeType(__arg0, setIndex, rangeIndex);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCategory(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long setIndex, long rangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetDescriptorSetDescriptorRangeCategory(__arg0, setIndex, rangeIndex);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetSubObjectRangeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSubObjectRangeCount(__arg0);
            return ___ret;
        }

        public static long SpReflectionTypeLayoutGetSubObjectRangeBindingRangeIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long subObjectRangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSubObjectRangeBindingRangeIndex(__arg0, subObjectRangeIndex);
            return ___ret;
        }

        /// <summary>Get the space offset for a sub-object range.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static long SpReflectionTypeLayoutGetSubObjectRangeSpaceOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long subObjectRangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSubObjectRangeSpaceOffset(__arg0, subObjectRangeIndex);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionTypeLayoutGetSubObjectRangeOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout typeLayout, long subObjectRangeIndex)
        {
            var __arg0 = typeLayout is null ? __IntPtr.Zero : typeLayout.__Instance;
            var ___ret = __Internal.SpReflectionTypeLayoutGetSubObjectRangeOffset(__arg0, subObjectRangeIndex);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionVariableGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionVariableGetType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableGetType(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier SpReflectionVariableFindModifier(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableFindModifier(__arg0, modifierID);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionVariableGetUserAttributeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableGetUserAttributeCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionVariableGetUserAttribute(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var, uint index)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableGetUserAttribute(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionVariableFindUserAttributeByName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var __arg1 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
            var ___ret = __Internal.SpReflectionVariableFindUserAttributeByName(__arg0, __arg1, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static bool SpReflectionVariableHasDefaultValue(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable inVar)
        {
            var __arg0 = inVar is null ? __IntPtr.Zero : inVar.__Instance;
            var ___ret = __Internal.SpReflectionVariableHasDefaultValue(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpReflectionVariableGetDefaultValueInt(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable inVar, ref long rs)
        {
            var __arg0 = inVar is null ? __IntPtr.Zero : inVar.__Instance;
            fixed (long* __rs1 = &rs)
            {
                var __arg1 = __rs1;
                var ___ret = __Internal.SpReflectionVariableGetDefaultValueInt(__arg0, __arg1);
                return ___ret;
            }
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionVariableGetGenericContainer(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableGetGenericContainer(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionVariableApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable var, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var __arg1 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionVariableApplySpecializations(__arg0, __arg1);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionVariableLayoutGetVariable(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetVariable(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionVariableLayoutGetTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetTypeLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the offset of a variable in the specified parameter category.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the offset depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionVariableLayoutGetOffset(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetOffset(__arg0, category);
            return ___ret;
        }

        /// <summary>Get the register space/set of a variable in the specified parameter category.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the space depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionVariableLayoutGetSpace(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetSpace(__arg0, category);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangImageFormat SpReflectionVariableLayoutGetImageFormat(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetImageFormat(__arg0);
            return ___ret;
        }

        public static string SpReflectionVariableLayoutGetSemanticName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetSemanticName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static ulong SpReflectionVariableLayoutGetSemanticIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetSemanticIndex(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl SpReflectionFunctionAsDecl(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionAsDecl(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionFunctionGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier SpReflectionFunctionFindModifier(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction var, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionFunctionFindModifier(__arg0, modifierID);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionFunctionGetUserAttributeCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetUserAttributeCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionFunctionGetUserAttribute(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, uint index)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetUserAttribute(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute SpReflectionFunctionFindUserAttributeByName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, global::ShaderSlang.Net.Bindings.Generated.Slang.IGlobalSession globalSession, string name)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var __arg1 = globalSession is null ? __IntPtr.Zero : globalSession.__PointerToIGlobalSession;
            var ___ret = __Internal.SpReflectionFunctionFindUserAttributeByName(__arg0, __arg1, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionUserAttribute.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionFunctionGetParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionFunctionGetParameter(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, uint index)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetParameter(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionFunctionGetResultType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetResultType(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionFunctionGetGenericContainer(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetGenericContainer(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionFunctionApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var __arg1 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionFunctionApplySpecializations(__arg0, __arg1);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionFunctionSpecializeWithArgTypes(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, long argTypeCount, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType argTypes)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ____arg2 = argTypes is null ? __IntPtr.Zero : argTypes.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpReflectionFunctionSpecializeWithArgTypes(__arg0, argTypeCount, __arg2);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static bool SpReflectionFunctionIsOverloaded(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionIsOverloaded(__arg0);
            return ___ret;
        }

        public static uint SpReflectionFunctionGetOverloadCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetOverloadCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionFunctionGetOverload(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction func, uint index)
        {
            var __arg0 = func is null ? __IntPtr.Zero : func.__Instance;
            var ___ret = __Internal.SpReflectionFunctionGetOverload(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionDeclGetChildrenCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl parentDecl)
        {
            var __arg0 = parentDecl is null ? __IntPtr.Zero : parentDecl.__Instance;
            var ___ret = __Internal.SpReflectionDeclGetChildrenCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl SpReflectionDeclGetChild(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl parentDecl, uint index)
        {
            var __arg0 = parentDecl is null ? __IntPtr.Zero : parentDecl.__Instance;
            var ___ret = __Internal.SpReflectionDeclGetChild(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionDeclGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind SpReflectionDeclGetKind(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclGetKind(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionDeclCastToFunction(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclCastToFunction(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionDeclCastToVariable(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclCastToVariable(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionDeclCastToGeneric(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclCastToGeneric(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionGetTypeFromDecl(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionGetTypeFromDecl(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl SpReflectionDeclGetParent(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclGetParent(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier SpReflectionDeclFindModifier(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl decl, global::ShaderSlang.Net.Bindings.Generated.SlangModifierID modifierID)
        {
            var __arg0 = decl is null ? __IntPtr.Zero : decl.__Instance;
            var ___ret = __Internal.SpReflectionDeclFindModifier(__arg0, modifierID);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionModifier.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl SpReflectionGenericAsDecl(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericAsDecl(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpReflectionGenericGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static uint SpReflectionGenericGetTypeParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetTypeParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionGenericGetTypeParameter(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, uint index)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetTypeParameter(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionGenericGetValueParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetValueParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionGenericGetValueParameter(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, uint index)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetValueParameter(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionGenericGetTypeParameterConstraintCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable typeParam)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var __arg1 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetTypeParameterConstraintCount(__arg0, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionGenericGetTypeParameterConstraintType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable typeParam, uint index)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var __arg1 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetTypeParameterConstraintType(__arg0, __arg1, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangDeclKind SpReflectionGenericGetInnerKind(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetInnerKind(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl SpReflectionGenericGetInnerDecl(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetInnerDecl(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionDecl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionGenericGetOuterGenericContainer(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetOuterGenericContainer(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionGenericGetConcreteType(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable typeParam)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var __arg1 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetConcreteType(__arg0, __arg1);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static long SpReflectionGenericGetConcreteIntVal(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable valueParam)
        {
            var __arg0 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var __arg1 = valueParam is null ? __IntPtr.Zero : valueParam.__Instance;
            var ___ret = __Internal.SpReflectionGenericGetConcreteIntVal(__arg0, __arg1);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionGenericApplySpecializations(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric currGeneric, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic)
        {
            var __arg0 = currGeneric is null ? __IntPtr.Zero : currGeneric.__Instance;
            var __arg1 = generic is null ? __IntPtr.Zero : generic.__Instance;
            var ___ret = __Internal.SpReflectionGenericApplySpecializations(__arg0, __arg1);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the stage that a variable belongs to (if any).</summary>
        /// <remarks>
        /// <para>A variable &quot;belongs&quot; to a specific stage when it is a varying input/output</para>
        /// <para>parameter either defined as part of the parameter list for an entry</para>
        /// <para>point *or* at the global scope of a stage-specific GLSL code file (e.g.,</para>
        /// <para>an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).</para>
        /// </remarks>
        public static global::ShaderSlang.Net.Bindings.Generated.SlangStage SpReflectionVariableLayoutGetStage(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetStage(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionVariableLayoutGetPendingDataLayout(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout var)
        {
            var __arg0 = var is null ? __IntPtr.Zero : var.__Instance;
            var ___ret = __Internal.SpReflectionVariableLayoutGetPendingDataLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the binding index for a shader parameter.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the index depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static uint SpReflectionParameterGetBindingIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout parameter)
        {
            var __arg0 = parameter is null ? __IntPtr.Zero : parameter.__Instance;
            var ___ret = __Internal.SpReflectionParameterGetBindingIndex(__arg0);
            return ___ret;
        }

        /// <summary>Get the binding space for a shader parameter.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the space depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static uint SpReflectionParameterGetBindingSpace(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout parameter)
        {
            var __arg0 = parameter is null ? __IntPtr.Zero : parameter.__Instance;
            var ___ret = __Internal.SpReflectionParameterGetBindingSpace(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpIsParameterLocationUsed(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, long entryPointIndex, long targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category, ulong spaceIndex, ulong registerIndex, ref bool outUsed)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            fixed (bool* __outUsed6 = &outUsed)
            {
                var __arg6 = __outUsed6;
                var ___ret = __Internal.SpIsParameterLocationUsed(__arg0, entryPointIndex, targetIndex, category, spaceIndex, registerIndex, __arg6);
                return ___ret;
            }
        }

        public static string SpReflectionEntryPointGetName(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static string SpReflectionEntryPointGetNameOverride(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetNameOverride(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionEntryPointGetFunction(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetFunction(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionEntryPointGetParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionEntryPointGetParameterByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint, uint index)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetParameterByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangStage SpReflectionEntryPointGetStage(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetStage(__arg0);
            return ___ret;
        }

        public static void SpReflectionEntryPointGetComputeThreadGroupSize(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint, ulong axisCount, ref ulong outSizeAlongAxis)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            fixed (ulong* __outSizeAlongAxis2 = &outSizeAlongAxis)
            {
                var __arg2 = __outSizeAlongAxis2;
                __Internal.SpReflectionEntryPointGetComputeThreadGroupSize(__arg0, axisCount, __arg2);
            }
        }

        public static void SpReflectionEntryPointGetComputeWaveSize(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint, ref ulong outWaveSize)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            fixed (ulong* __outWaveSize1 = &outWaveSize)
            {
                var __arg1 = __outWaveSize1;
                __Internal.SpReflectionEntryPointGetComputeWaveSize(__arg0, __arg1);
            }
        }

        public static int SpReflectionEntryPointUsesAnySampleRateInput(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointUsesAnySampleRateInput(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionEntryPointGetVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionEntryPointGetResultVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointGetResultVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static int SpReflectionEntryPointHasDefaultConstantBuffer(global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout entryPoint)
        {
            var __arg0 = entryPoint is null ? __IntPtr.Zero : entryPoint.__Instance;
            var ___ret = __Internal.SpReflectionEntryPointHasDefaultConstantBuffer(__arg0);
            return ___ret;
        }

        public static string SpReflectionTypeParameterGetName(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter typeParam)
        {
            var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionTypeParameterGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static uint SpReflectionTypeParameterGetIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter typeParam)
        {
            var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionTypeParameterGetIndex(__arg0);
            return ___ret;
        }

        public static uint SpReflectionTypeParameterGetConstraintCount(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter typeParam)
        {
            var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionTypeParameterGetConstraintCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionTypeParameterGetConstraintByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter typeParam, uint index)
        {
            var __arg0 = typeParam is null ? __IntPtr.Zero : typeParam.__Instance;
            var ___ret = __Internal.SpReflectionTypeParameterGetConstraintByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.SlangResult SpReflectionToJson(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg2 = outBlob is null ? __IntPtr.Zero : outBlob.__PointerToISlangBlob;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpReflectionToJson(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static uint SpReflectionGetParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionGetParameterByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, uint index)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetParameterByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint SpReflectionGetTypeParameterCount(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetTypeParameterCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter SpReflectionGetTypeParameterByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, uint index)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetTypeParameterByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter SpReflectionFindTypeParameter(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionFindTypeParameter(__arg0, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeParameter.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionFindTypeByName(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionFindTypeByName(__arg0, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionGetTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType reflectionType, global::ShaderSlang.Net.Bindings.Generated.SlangLayoutRules rules)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = reflectionType is null ? __IntPtr.Zero : reflectionType.__Instance;
            var ___ret = __Internal.SpReflectionGetTypeLayout(__arg0, __arg1, rules);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionFindFunctionByName(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionFindFunctionByName(__arg0, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionFindFunctionByNameInType(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType reflType, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = reflType is null ? __IntPtr.Zero : reflType.__Instance;
            var ___ret = __Internal.SpReflectionFindFunctionByNameInType(__arg0, __arg1, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable SpReflectionFindVarByNameInType(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType reflType, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = reflType is null ? __IntPtr.Zero : reflType.__Instance;
            var ___ret = __Internal.SpReflectionFindVarByNameInType(__arg0, __arg1, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction SpReflectionTryResolveOverloadedFunction(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, uint candidateCount, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction candidates)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ____arg2 = candidates is null ? __IntPtr.Zero : candidates.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpReflectionTryResolveOverloadedFunction(__arg0, candidateCount, __arg2);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionFunction.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static ulong SpReflectionGetEntryPointCount(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetEntryPointCount(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout SpReflectionGetEntryPointByIndex(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, ulong index)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetEntryPointByIndex(__arg0, index);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout SpReflectionFindEntryPointByName(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, string name)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionFindEntryPointByName(__arg0, name);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangEntryPointLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the binding index for the global constant buffer.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the binding depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionGetGlobalConstantBufferBinding(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetGlobalConstantBufferBinding(__arg0);
            return ___ret;
        }

        /// <summary>Get the size of the global constant buffer.</summary>
        /// <remarks>
        /// <para>Returns `SLANG_UNBOUNDED_SIZE` for unbounded resources.</para>
        /// <para>Returns `SLANG_UNKNOWN_SIZE` when the size depends on unresolved generic parameters or</para>
        /// <para>link-time constants.</para>
        /// </remarks>
        public static ulong SpReflectionGetGlobalConstantBufferSize(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetGlobalConstantBufferSize(__arg0);
            return ___ret;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType SpReflectionSpecializeType(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType type, long specializationArgCount, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType specializationArgs, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = type is null ? __IntPtr.Zero : type.__Instance;
            var ____arg3 = specializationArgs is null ? __IntPtr.Zero : specializationArgs.__Instance;
            var __arg3 = new __IntPtr(&____arg3);
            var ____arg4 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
            var __arg4 = new __IntPtr(&____arg4);
            var ___ret = __Internal.SpReflectionSpecializeType(__arg0, __arg1, specializationArgCount, __arg3, __arg4);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric SpReflectionSpecializeGeneric(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout inProgramLayout, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric generic, long argCount, ref global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType argTypes, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArg args, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outDiagnostics)
        {
            var __arg0 = inProgramLayout is null ? __IntPtr.Zero : inProgramLayout.__Instance;
            var __arg1 = generic is null ? __IntPtr.Zero : generic.__Instance;
            fixed (global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGenericArgType* __argTypes3 = &argTypes)
            {
                var __arg3 = __argTypes3;
                var ____arg4 = args.__Instance;
                var __arg4 = new __IntPtr(&____arg4);
                var ____arg5 = outDiagnostics is null ? __IntPtr.Zero : outDiagnostics.__PointerToISlangBlob;
                var __arg5 = new __IntPtr(&____arg5);
                var ___ret = __Internal.SpReflectionSpecializeGeneric(__arg0, __arg1, argCount, __arg3, __arg4, __arg5);
                var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionGeneric.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }

        public static bool SpReflectionIsSubType(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType subType, global::ShaderSlang.Net.Bindings.Generated.SlangReflectionType superType)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var __arg1 = subType is null ? __IntPtr.Zero : subType.__Instance;
            var __arg2 = superType is null ? __IntPtr.Zero : superType.__Instance;
            var ___ret = __Internal.SpReflectionIsSubType(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Get the number of hashed strings</summary>
        public static ulong SpReflectionGetHashedStringCount(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetHashedStringCount(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get a hashed string. The number of chars is written in outCount.</para>
        /// <para>The count does *NOT* including terminating 0. The returned string will be 0 terminated.</para>
        /// </summary>
        public static string SpReflectionGetHashedString(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection, ulong index, ref ulong outCount)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            fixed (ulong* __outCount2 = &outCount)
            {
                var __arg2 = __outCount2;
                var ___ret = __Internal.SpReflectionGetHashedString(__arg0, index, __arg2);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }
        }

        /// <summary>
        /// <para>Compute a string hash.</para>
        /// <para>Count should *NOT* include terminating zero.</para>
        /// </summary>
        public static uint SpComputeStringHash(string chars, ulong count)
        {
            var ___ret = __Internal.SpComputeStringHash(chars, count);
            return ___ret;
        }

        /// <summary>Get a type layout representing reflection information for the global-scope parameters.</summary>
        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout SpReflectionGetGlobalParamsTypeLayout(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetGlobalParamsTypeLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionTypeLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a variable layout representing reflection information for the global-scope parameters.</summary>
        public static global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout SpReflectionGetGlobalParamsVarLayout(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetGlobalParamsVarLayout(__arg0);
            var __result0 = global::ShaderSlang.Net.Bindings.Generated.SlangReflectionVariableLayout.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static string SpGetTranslationUnitSource(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, int translationUnitIndex)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ___ret = __Internal.SpGetTranslationUnitSource(__arg0, translationUnitIndex);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::ShaderSlang.Net.Bindings.Generated.Slang.ISession SpReflectionGetSession(global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout reflection)
        {
            var __arg0 = reflection is null ? __IntPtr.Zero : reflection.__Instance;
            var ___ret = __Internal.SpReflectionGetSession(__arg0);
            var __result0 = ___ret != IntPtr.Zero ? global::ShaderSlang.Net.Bindings.Generated.Slang.ISession.__CreateInstance(___ret) : default;
            return __result0;
        }

        /// <remarks>slang::ICompileRequest::getProgram</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetProgram(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outProgram)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outProgram is null ? __IntPtr.Zero : outProgram.__PointerToIComponentType;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpCompileRequestGetProgram(__arg0, __arg1);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getProgramWithEntryPoints</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetProgramWithEntryPoints(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outProgram)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outProgram is null ? __IntPtr.Zero : outProgram.__PointerToIComponentType;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpCompileRequestGetProgramWithEntryPoints(__arg0, __arg1);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getEntryPoint</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetEntryPoint(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, long entryPointIndex, global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outEntryPoint)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg2 = outEntryPoint is null ? __IntPtr.Zero : outEntryPoint.__PointerToIComponentType;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpCompileRequestGetEntryPoint(__arg0, entryPointIndex, __arg2);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getModule</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetModule(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, long translationUnitIndex, global::ShaderSlang.Net.Bindings.Generated.Slang.IModule outModule)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg2 = outModule is null ? __IntPtr.Zero : outModule.__PointerToIModule;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.SpCompileRequestGetModule(__arg0, translationUnitIndex, __arg2);
            return ___ret;
        }

        /// <remarks>slang::ICompileRequest::getSession</remarks>
        public static global::ShaderSlang.Net.Bindings.SlangResult SpCompileRequestGetSession(global::ShaderSlang.Net.Bindings.Generated.Slang.ICompileRequest request, global::ShaderSlang.Net.Bindings.Generated.Slang.ISession outSession)
        {
            var __arg0 = request is null ? __IntPtr.Zero : request.__PointerToICompileRequest;
            var ____arg1 = outSession is null ? __IntPtr.Zero : outSession.__PointerToISession;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.SpCompileRequestGetSession(__arg0, __arg1);
            return ___ret;
        }
    }

    namespace Slang
    {
        /// <summary>A request for one or more compilation actions to be performed.</summary>
        [global::System.Runtime.InteropServices.GuidAttribute("96d33993-317c-4db5-afd8-666ee77248e2")]
        [global::System.Runtime.InteropServices.Marshalling.GeneratedComInterfaceAttribute(StringMarshalling = global::System.Runtime.InteropServices.StringMarshalling.Utf8)]
        public unsafe partial interface ICompileRequest : global::ShaderSlang.Net.Bindings.Generated.ISlangUnknown
        {
            /// <summary>Set the filesystem hook to use for a compile request</summary>
            /// <remarks>
            /// <para>The provided `fileSystem` will be used to load any files that</para>
            /// <para>need to be loaded during processing of the compile `request`.</para>
            /// <para>This includes:</para>
            /// <para>- Source files loaded via `spAddTranslationUnitSourceFile`</para>
            /// <para>- Files referenced via `#include`</para>
            /// <para>- Files loaded to resolve `#import` operations</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetFileSystem(global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem fileSystem);

            /// <summary>Set flags to be used for compilation.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetCompileFlags(uint flags);

            /// <summary>Returns the compilation flags previously set with `setCompileFlags`</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            uint GetCompileFlags();

            /// <summary>Set whether to dump intermediate results (for debugging) or not.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDumpIntermediates(int enable);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDumpIntermediatePrefix(string prefix);

            /// <summary>Set whether (and how) `#line` directives should be output.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetLineDirectiveMode(global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode);

            /// <summary>Sets the target for code generation.</summary>
            /// <param name="target">
            /// <para>The code generation target. Possible values are:</para>
            /// <para>- SLANG_GLSL. Generates GLSL code.</para>
            /// <para>- SLANG_HLSL. Generates HLSL code.</para>
            /// <para>- SLANG_SPIRV. Generates SPIR-V code.</para>
            /// </param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetCodeGenTarget(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            /// <summary>Add a code-generation target to be used.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int AddCodeGenTarget(global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget target);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetProfile(int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangProfileID profile);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetFlags(int targetIndex, uint flags);

            /// <summary>Set the floating point mode (e.g., precise or fast) to use a target.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetFloatingPointMode(int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode mode);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetMatrixLayoutMode(int targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetMatrixLayoutMode(global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode mode);

            /// <summary>Set the level of debug information to produce.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDebugInfoLevel(global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoLevel level);

            /// <summary>Set the level of optimization to perform.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetOptimizationLevel(global::ShaderSlang.Net.Bindings.Generated.SlangOptimizationLevel level);

            /// <summary>Set the container format to be used for binary output.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetOutputContainerFormat(global::ShaderSlang.Net.Bindings.Generated.SlangContainerFormat format);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetPassThrough(global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough passThrough);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDiagnosticCallback(global::ShaderSlang.Net.Bindings.Generated.SlangDiagnosticCallback callback, __IntPtr userData);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetWriter(global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel, global::ShaderSlang.Net.Bindings.Generated.ISlangWriter writer);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.ISlangWriter GetWriter(global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel channel);

            /// <summary>
            /// <para>Add a path to use when searching for referenced files.</para>
            /// <para>This will be used for both `#include` directives and also for explicit `__import` declarations.</para>
            /// </summary>
            /// <param name="ctx">The compilation context.</param>
            /// <param name="searchDir">The additional search directory.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddSearchPath(string searchDir);

            /// <summary>Add a macro definition to be used during preprocessing.</summary>
            /// <param name="key">The name of the macro to define.</param>
            /// <param name="value">The value of the macro to define.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddPreprocessorDefine(string key, string value);

            /// <summary>Set options using arguments as if specified via command line.</summary>
            /// <returns>Returns SlangResult. On success SLANG_SUCCEEDED(result) is true.</returns>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult ProcessCommandLineArguments(char** args, int argCount);

            /// <summary>Add a distinct translation unit to the compilation request</summary>
            /// <remarks>
            /// <para>`name` is optional.</para>
            /// <para>Returns the zero-based index of the translation unit created.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int AddTranslationUnit(global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage language, string name);

            /// <summary>
            /// <para>Set a default module name. Translation units will default to this module name if one is not</para>
            /// <para>passed. If not set each translation unit will get a unique name.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDefaultModuleName(string defaultModuleName);

            /// <summary>Add a preprocessor definition that is scoped to a single translation unit.</summary>
            /// <param name="translationUnitIndex">The index of the translation unit to get the definition.</param>
            /// <param name="key">The name of the macro to define.</param>
            /// <param name="value">The value of the macro to define.</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddTranslationUnitPreprocessorDefine(int translationUnitIndex, string key, string value);

            /// <summary>Add a source file to the given translation unit.</summary>
            /// <remarks>
            /// <para>If a user-defined file system has been specified via</para>
            /// <para>`spSetFileSystem`, then it will be used to load the</para>
            /// <para>file at `path`. Otherwise, Slang will use the OS</para>
            /// <para>file system.</para>
            /// <para>This function does *not* search for a file using</para>
            /// <para>the registered search paths (`spAddSearchPath`),</para>
            /// <para>and instead using the given `path` as-is.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddTranslationUnitSourceFile(int translationUnitIndex, string path);

            /// <summary>Add a source string to the given translation unit.</summary>
            /// <param name="translationUnitIndex">The index of the translation unit to add source to.</param>
            /// <param name="path">The file-system path that should be assumed for the source code.</param>
            /// <param name="source">A null-terminated UTF-8 encoded string of source code.</param>
            /// <remarks>
            /// <para>The implementation will make a copy of the source code data.</para>
            /// <para>An application may free the buffer immediately after this call returns.</para>
            /// <para>The `path` will be used in any diagnostic output, as well</para>
            /// <para>as to determine the base path when resolving relative</para>
            /// <para>`#include`s.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddTranslationUnitSourceString(int translationUnitIndex, string path, string source);

            /// <summary>
            /// <para>Add a slang library - such that its contents can be referenced during linking.</para>
            /// <para>This is equivalent to the -r command line option.</para>
            /// </summary>
            /// <param name="basePath">The base path used to lookup referenced modules.</param>
            /// <param name="libData">The library data</param>
            /// <param name="libDataSize">The size of the library data</param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult AddLibraryReference(string basePath, __IntPtr libData, ulong libDataSize);

            /// <summary>Add a source string to the given translation unit.</summary>
            /// <param name="translationUnitIndex">The index of the translation unit to add source to.</param>
            /// <param name="path">The file-system path that should be assumed for the source code.</param>
            /// <param name="sourceBegin">A pointer to a buffer of UTF-8 encoded source code.</param>
            /// <param name="sourceEnd">A pointer to to the end of the buffer specified in `sourceBegin`</param>
            /// <remarks>
            /// <para>The implementation will make a copy of the source code data.</para>
            /// <para>An application may free the buffer immediately after this call returns.</para>
            /// <para>The `path` will be used in any diagnostic output, as well</para>
            /// <para>as to determine the base path when resolving relative</para>
            /// <para>`#include`s.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddTranslationUnitSourceStringSpan(int translationUnitIndex, string path, string sourceBegin, string sourceEnd);

            /// <summary>Add a blob of source code to the given translation unit.</summary>
            /// <param name="translationUnitIndex">The index of the translation unit to add source to.</param>
            /// <param name="path">The file-system path that should be assumed for the source code.</param>
            /// <param name="sourceBlob">A blob containing UTF-8 encoded source code.</param>
            /// <param name="sourceEnd">A pointer to to the end of the buffer specified in `sourceBegin`</param>
            /// <remarks>
            /// <para>The compile request will retain a reference to the blob.</para>
            /// <para>The `path` will be used in any diagnostic output, as well</para>
            /// <para>as to determine the base path when resolving relative</para>
            /// <para>`#include`s.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void AddTranslationUnitSourceBlob(int translationUnitIndex, string path, global::ShaderSlang.Net.Bindings.Generated.ISlangBlob sourceBlob);

            /// <summary>Add an entry point in a particular translation unit</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int AddEntryPoint(int translationUnitIndex, string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage);

            /// <summary>
            /// <para>Add an entry point in a particular translation unit,</para>
            /// <para>with additional arguments that specify the concrete</para>
            /// <para>type names for entry-point generic type parameters.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int AddEntryPointEx(int translationUnitIndex, string name, global::ShaderSlang.Net.Bindings.Generated.SlangStage stage, int genericArgCount, char** genericArgs);

            /// <summary>Specify the arguments to use for global generic parameters.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetGlobalGenericArgs(int genericArgCount, char** genericArgs);

            /// <summary>Specify the concrete type to be used for a global &quot;existential slot.&quot;</summary>
            /// <remarks>
            /// <para>Every shader parameter (or leaf field of a `struct`-type shader parameter)</para>
            /// <para>that has an interface or array-of-interface type introduces an existential</para>
            /// <para>slot. The number of slots consumed by a shader parameter, and the starting</para>
            /// <para>slot of each parameter can be queried via the reflection API using</para>
            /// <para>`SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.</para>
            /// <para>In order to generate specialized code, a concrete type needs to be specified</para>
            /// <para>for each existential slot. This function specifies the name of the type</para>
            /// <para>(or in general a type *expression*) to use for a specific slot at the</para>
            /// <para>global scope.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetTypeNameForGlobalExistentialTypeParam(int slotIndex, string typeName);

            /// <summary>Specify the concrete type to be used for an entry-point &quot;existential slot.&quot;</summary>
            /// <remarks>
            /// <para>Every shader parameter (or leaf field of a `struct`-type shader parameter)</para>
            /// <para>that has an interface or array-of-interface type introduces an existential</para>
            /// <para>slot. The number of slots consumed by a shader parameter, and the starting</para>
            /// <para>slot of each parameter can be queried via the reflection API using</para>
            /// <para>`SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.</para>
            /// <para>In order to generate specialized code, a concrete type needs to be specified</para>
            /// <para>for each existential slot. This function specifies the name of the type</para>
            /// <para>(or in general a type *expression*) to use for a specific slot at the</para>
            /// <para>entry-point scope.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SetTypeNameForEntryPointExistentialTypeParam(int entryPointIndex, int slotIndex, string typeName);

            /// <summary>Enable or disable an experimental, best-effort GLSL frontend</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetAllowGLSLInput([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            /// <summary>Execute the compilation request.</summary>
            /// <remarks>
            /// <para>SlangResult, SLANG_OK on success. Use SLANG_SUCCEEDED() and SLANG_FAILED() to test</para>
            /// <para>SlangResult.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult Compile();

            /// <summary>Get any diagnostic messages reported by the compiler.</summary>
            /// <remarks>
            /// <para>A null-terminated UTF-8 encoded string of diagnostic messages.</para>
            /// <para>The returned pointer is only guaranteed to be valid</para>
            /// <para>until `request` is destroyed. Applications that wish to</para>
            /// <para>hold on to the diagnostic output for longer should use</para>
            /// <para>`getDiagnosticOutputBlob`.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetDiagnosticOutput();

            /// <summary>Get diagnostic messages reported by the compiler.</summary>
            /// <param name="outBlob">
            /// <para>A pointer to receive a blob holding a nul-terminated UTF-8 encoded string of</para>
            /// <para>diagnostic messages.</para>
            /// </param>
            /// <remarks>A `SlangResult` indicating success or failure.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetDiagnosticOutputBlob(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Get the number of files that this compilation depended on.</summary>
            /// <remarks>
            /// <para>This includes both the explicit source files, as well as any</para>
            /// <para>additional files that were transitively referenced (e.g., via</para>
            /// <para>a `#include` directive).</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int GetDependencyFileCount();

            /// <summary>Get the path to a file this compilation depended on.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetDependencyFilePath(int index);

            /// <summary>Get the number of translation units associated with the compilation request</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int GetTranslationUnitCount();

            /// <summary>Get the output source code associated with a specific entry point.</summary>
            /// <remarks>The lifetime of the output pointer is the same as `request`.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            string GetEntryPointSource(int entryPointIndex);

            /// <summary>Get the output bytecode associated with a specific entry point.</summary>
            /// <remarks>The lifetime of the output pointer is the same as `request`.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            __IntPtr GetEntryPointCode(int entryPointIndex, out ulong outSize);

            /// <summary>Get the output code associated with a specific entry point.</summary>
            /// <param name="entryPointIndex">The index of the entry point to get code for.</param>
            /// <param name="targetIndex">The index of the target to get code for (default: zero).</param>
            /// <param name="outBlob">A pointer that will receive the blob of code</param>
            /// <remarks>A `SlangResult` to indicate success or failure.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointCodeBlob(int entryPointIndex, int targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.</summary>
            /// <param name="entryPointIndex">The index of the entry point to get code for.</param>
            /// <param name="targetIndex">The index of the target to get code for (default: zero).</param>
            /// <param name="outSharedLibrary">
            /// <para>A pointer to a ISharedLibrary interface which functions can be queried</para>
            /// <para>on.</para>
            /// </param>
            /// <remarks>
            /// <para>That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.</para>
            /// <para>NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.</para>
            /// <para>A `SlangResult` to indicate success or failure.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPointHostCallable(int entryPointIndex, int targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary outSharedLibrary);

            /// <summary>Get the output code associated with a specific target.</summary>
            /// <param name="targetIndex">The index of the target to get code for (default: zero).</param>
            /// <param name="outBlob">A pointer that will receive the blob of code</param>
            /// <remarks>A `SlangResult` to indicate success or failure.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTargetCodeBlob(int targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Get 'callable' functions for a target accessible through the ISlangSharedLibrary interface.</summary>
            /// <param name="targetIndex">The index of the target to get code for (default: zero).</param>
            /// <param name="outSharedLibrary">
            /// <para>A pointer to a ISharedLibrary interface which functions can be queried</para>
            /// <para>on.</para>
            /// </param>
            /// <remarks>
            /// <para>That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.</para>
            /// <para>NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.</para>
            /// <para>A `SlangResult` to indicate success or failure.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetTargetHostCallable(int targetIndex, out global::ShaderSlang.Net.Bindings.Generated.ISlangSharedLibrary outSharedLibrary);

            /// <summary>Get the output bytecode associated with an entire compile request.</summary>
            /// <param name="outSize">
            /// <para>The size of the containers contents in bytes. Will be zero if there is</para>
            /// <para>no code available.</para>
            /// </param>
            /// <remarks>
            /// <para>The lifetime of the output pointer is the same as `request` and the last spCompile.</para>
            /// <para>Pointer to start of the contained data, or nullptr if there is no code</para>
            /// <para>available.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            __IntPtr GetCompileRequestCode(out ulong outSize);

            /// <summary>
            /// <para>Get the compilation result as a file system.</para>
            /// <para>The result is not written to the actual OS file system, but is made available as an</para>
            /// <para>in memory representation.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.ISlangMutableFileSystem GetCompileRequestResultAsFileSystem();

            /// <summary>
            /// <para>Return the container code as a blob. The container blob is created as part of a compilation</para>
            /// <para>(with spCompile), and a container is produced with a suitable ContainerFormat.</para>
            /// </summary>
            /// <param name="outSize">The blob containing the container data.</param>
            /// <remarks>A `SlangResult` to indicate success or failure.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetContainerCode(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Load repro from memory specified.</summary>
            /// <param name="fileSystem">
            /// <para>An (optional) filesystem. Pass nullptr to just use contents of repro</para>
            /// <para>held in data.</para>
            /// </param>
            /// <param name="data">The data to load from.</param>
            /// <param name="size">The size of the data to load from.</param>
            /// <remarks>
            /// <para>Should only be performed on a newly created request.</para>
            /// <para>NOTE! When using the fileSystem, files will be loaded via their `unique names` as if they are</para>
            /// <para>part of the flat file system. This mechanism is described more fully in docs/repro.md.</para>
            /// <para>A `SlangResult` to indicate success or failure.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult LoadRepro(global::ShaderSlang.Net.Bindings.Generated.ISlangFileSystem fileSystem, __IntPtr data, ulong size);

            /// <summary>
            /// <para>Save repro state. Should *typically* be performed after spCompile, so that everything</para>
            /// <para>that is needed for a compilation is available.</para>
            /// </summary>
            /// <param name="outBlob">Blob that will hold the serialized state</param>
            /// <remarks>A `SlangResult` to indicate success or failure.</remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult SaveRepro(out global::ShaderSlang.Net.Bindings.Generated.ISlangBlob outBlob);

            /// <summary>Enable repro capture.</summary>
            /// <remarks>
            /// <para>Should be set after any ISlangFileSystem has been set, but before any compilation. It ensures</para>
            /// <para>that everything that the ISlangFileSystem accesses will be correctly recorded. Note that if a</para>
            /// <para>ISlangFileSystem/ISlangFileSystemExt isn't explicitly set (ie the default is used), then the</para>
            /// <para>request will automatically be set up to record everything appropriate.</para>
            /// <para>A `SlangResult` to indicate success or failure.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult EnableReproCapture();

            /// <summary>Get the (linked) program for a compile request.</summary>
            /// <remarks>
            /// <para>The linked program will include all of the global-scope modules for the</para>
            /// <para>translation units in the program, plus any modules that they `import`</para>
            /// <para>(transitively), specialized to any global specialization arguments that</para>
            /// <para>were provided via the API.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetProgram(out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outProgram);

            /// <summary>Get the (partially linked) component type for an entry point.</summary>
            /// <remarks>
            /// <para>The returned component type will include the entry point at the</para>
            /// <para>given index, and will be specialized using any specialization arguments</para>
            /// <para>that were provided for it via the API.</para>
            /// <para>The returned component will *not* include the modules representing</para>
            /// <para>the global scope and its dependencies/specialization, so a client</para>
            /// <para>program will typically want to compose this component type with</para>
            /// <para>the one returned by `spCompileRequest_getProgram` to get a complete</para>
            /// <para>and usable component type from which kernel code can be requested.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetEntryPoint(long entryPointIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outEntryPoint);

            /// <summary>Get the (un-linked) module for a translation unit.</summary>
            /// <remarks>
            /// <para>The returned module will not be linked against any dependencies,</para>
            /// <para>nor against any entry points (even entry points declared inside</para>
            /// <para>the module). Similarly, the module will not be specialized</para>
            /// <para>to the arguments that might have been provided via the API.</para>
            /// <para>This function provides an atomic unit of loaded code that</para>
            /// <para>is suitable for looking up types and entry points in the</para>
            /// <para>given module, and for linking together to produce a composite</para>
            /// <para>program that matches the needs of an application.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetModule(long translationUnitIndex, out global::ShaderSlang.Net.Bindings.Generated.Slang.IModule outModule);

            /// <summary>
            /// <para>Get the `ISession` handle behind the `SlangCompileRequest`.</para>
            /// <para>TODO(JS): Arguably this should just return the session pointer.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetSession(out global::ShaderSlang.Net.Bindings.Generated.Slang.ISession outSession);

            /// <summary>get reflection data from a compilation request </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.Generated.SlangProgramLayout GetReflection();

            /// <summary>Make output specially handled for command line output </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetCommandLineCompilerMode();

            /// <summary>Add a defined capability that should be assumed available on the target </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult AddTargetCapability(long targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID capability);

            /// <summary>Get the (linked) program for a compile request, including all entry points.</summary>
            /// <remarks>
            /// <para>The resulting program will include all of the global-scope modules for the</para>
            /// <para>translation units in the program, plus any modules that they `import`</para>
            /// <para>(transitively), specialized to any global specialization arguments that</para>
            /// <para>were provided via the API, as well as all entry points specified for compilation,</para>
            /// <para>specialized to their entry-point specialization arguments.</para>
            /// </remarks>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetProgramWithEntryPoints(out global::ShaderSlang.Net.Bindings.Generated.Slang.IComponentType outProgram);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult IsParameterLocationUsed(long entryPointIndex, long targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory category, ulong spaceIndex, ulong registerIndex, out bool outUsed);

            /// <summary>Set the line directive mode for a target.</summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetLineDirectiveMode(long targetIndex, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode mode);

            /// <summary>
            /// <para>Set whether to use scalar buffer layouts for GLSL/Vulkan targets.</para>
            /// <para>If true, the generated GLSL/Vulkan code will use `scalar` layout for storage buffers.</para>
            /// <para>If false, the resulting code will std430 for storage buffers.</para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetForceGLSLScalarBufferLayout(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool forceScalarLayout);

            /// <summary>Overrides the severity of a specific diagnostic message.</summary>
            /// <param name="messageID">
            /// <para>Numeric identifier of the message to override,</para>
            /// <para>as defined in the 1st parameter of the DIAGNOSTIC macro.</para>
            /// </param>
            /// <param name="overrideSeverity">
            /// <para>New severity of the message. If the message is originally Error or</para>
            /// <para>Fatal, the new severity cannot be lower than that.</para>
            /// </param>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void OverrideDiagnosticSeverity(long messageID, global::ShaderSlang.Net.Bindings.Generated.SlangSeverity overrideSeverity);

            /// <summary>Returns the currently active flags of the request's diagnostic sink. </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            int GetDiagnosticFlags();

            /// <summary>
            /// <para>Sets the flags of the request's diagnostic sink.</para>
            /// <para>The previously specified flags are discarded. </para>
            /// </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDiagnosticFlags(int flags);

            /// <summary>Set the debug format to be used for debugging information </summary>
            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetDebugInfoFormat(global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoFormat debugFormat);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetEnableEffectAnnotations([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetReportDownstreamTime([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetReportPerfBenchmark([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetSkipSPIRVValidation([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetUseMinimumSlangOptimization(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetIgnoreCapabilityCheck([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            global::ShaderSlang.Net.Bindings.SlangResult GetCompileTimeProfile(global::ShaderSlang.Net.Bindings.Generated.ISlangProfiler compileTimeProfile, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool shouldClear);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetGenerateWholeProgram(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetForceDXLayout(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetEmbedDownstreamIR(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);

            [global::System.Runtime.InteropServices.PreserveSigAttribute()]
            [global::System.Runtime.InteropServices.UnmanagedCallConvAttribute(CallConvs = [typeof(System.Runtime.CompilerServices.CallConvStdcall)])]
            void SetTargetForceCLayout(int targetIndex, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.I1)] bool value);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangPathType_string8_string8___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangPathType arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8_ShaderSlang_Net_Bindings_Generated_SlangPathTypePtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, global::ShaderSlang.Net.Bindings.Generated.SlangPathType* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_PathKind_string8___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.PathKind arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8___IntPtr___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.Generated.OSPathKind Func_ShaderSlang_Net_Bindings_Generated_OSPathKind___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8___IntPtr_ulong(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, __IntPtr arg2, ulong arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate sbyte* Func_sbytePtr___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_sbytePtr_ulong(__IntPtr __instance, sbyte* arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8_ulong(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangWriterMode(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangWriterMode arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate long Func_long___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.Generated.SlangProfileID Func_ShaderSlang_Net_Bindings_Generated_SlangProfileID___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangPassThrough_string8(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangPassThrough___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangSourceLanguage_ShaderSlang_Net_Bindings_Generated_SlangPassThrough(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage arg1, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough Func_ShaderSlang_Net_Bindings_Generated_SlangPassThrough___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangSourceLanguage(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangSourceLanguage_string8(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangSourceLanguage___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangPassThrough(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr_ulong(__IntPtr __instance, __IntPtr arg1, ulong arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangArchiveType___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangArchiveType arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID Func_ShaderSlang_Net_Bindings_Generated_SlangCapabilityID___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget_ShaderSlang_Net_Bindings_Generated_SlangPassThrough(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg2, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough Func_ShaderSlang_Net_Bindings_Generated_SlangPassThrough___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_doublePtr_doublePtr(__IntPtr __instance, double* arg1, double* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_sbytePtrPtr___IntPtr___IntPtr(__IntPtr __instance, int arg1, sbyte** arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_Slang_BuiltinModuleName_uint(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName arg1, uint arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_Slang_BuiltinModuleName___IntPtr_ulong(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName arg1, __IntPtr arg2, ulong arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_Slang_BuiltinModuleName_ShaderSlang_Net_Bindings_Generated_SlangArchiveType___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.Slang.BuiltinModuleName arg1, global::ShaderSlang.Net.Bindings.Generated.SlangArchiveType arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint(__IntPtr __instance, uint arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangLineDirectiveMode(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_ShaderSlang_Net_Bindings_Generated_SlangProfileID(__IntPtr __instance, int arg1, global::ShaderSlang.Net.Bindings.Generated.SlangProfileID arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_uint(__IntPtr __instance, int arg1, uint arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_ShaderSlang_Net_Bindings_Generated_SlangFloatingPointMode(__IntPtr __instance, int arg1, global::ShaderSlang.Net.Bindings.Generated.SlangFloatingPointMode arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_ShaderSlang_Net_Bindings_Generated_SlangMatrixLayoutMode(__IntPtr __instance, int arg1, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangMatrixLayoutMode(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangMatrixLayoutMode arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangDebugInfoLevel(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoLevel arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangOptimizationLevel(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangOptimizationLevel arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangContainerFormat(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangContainerFormat arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangPassThrough(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangPassThrough arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangWriterChannel___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangWriterChannel(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangWriterChannel arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_sbytePtrPtr_int(__IntPtr __instance, sbyte** arg1, int arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangSourceLanguage_string8(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangSourceLanguage arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_string8_string8(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_string8(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_string8_string8_string8(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_string8___IntPtr(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_int_string8_ShaderSlang_Net_Bindings_Generated_SlangStage(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, global::ShaderSlang.Net.Bindings.Generated.SlangStage arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_int_string8_ShaderSlang_Net_Bindings_Generated_SlangStage_int_sbytePtrPtr(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, global::ShaderSlang.Net.Bindings.Generated.SlangStage arg3, int arg4, sbyte** arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_sbytePtrPtr(__IntPtr __instance, int arg1, sbyte** arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_string8(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_int_string8(__IntPtr __instance, int arg1, int arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.I1)] bool arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_int_ulongPtr(__IntPtr __instance, int arg1, ulong* arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_int___IntPtr(__IntPtr __instance, int arg1, int arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int___IntPtr(__IntPtr __instance, int arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_ulongPtr(__IntPtr __instance, ulong* arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr_ulong(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, ulong arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long___IntPtr(__IntPtr __instance, long arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long_ShaderSlang_Net_Bindings_Generated_SlangCapabilityID(__IntPtr __instance, long arg1, global::ShaderSlang.Net.Bindings.Generated.SlangCapabilityID arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long_long_ShaderSlang_Net_Bindings_Generated_SlangParameterCategory_ulong_ulong_boolPtr(__IntPtr __instance, long arg1, long arg2, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory arg3, ulong arg4, ulong arg5, bool* arg6);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_long_ShaderSlang_Net_Bindings_Generated_SlangLineDirectiveMode(__IntPtr __instance, long arg1, global::ShaderSlang.Net.Bindings.Generated.SlangLineDirectiveMode arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int_bool(__IntPtr __instance, int arg1, [MarshalAs(UnmanagedType.I1)] bool arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_long_ShaderSlang_Net_Bindings_Generated_SlangSeverity(__IntPtr __instance, long arg1, global::ShaderSlang.Net.Bindings.Generated.SlangSeverity arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangDebugInfoFormat(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangDebugInfoFormat arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr_bool(__IntPtr __instance, __IntPtr arg1, [MarshalAs(UnmanagedType.I1)] bool arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8_string8___IntPtr___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr_long___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, long arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr___IntPtr_long___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, long arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_long_ShaderSlang_Net_Bindings_Generated_Slang_LayoutRules___IntPtr(__IntPtr __instance, __IntPtr arg1, long arg2, global::ShaderSlang.Net.Bindings.Generated.Slang.LayoutRules arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_ShaderSlang_Net_Bindings_Generated_Slang_ContainerType___IntPtr(__IntPtr __instance, __IntPtr arg1, global::ShaderSlang.Net.Bindings.Generated.Slang.ContainerType arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr_uintPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, uint* arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr___IntPtr_long___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3, long arg4, __IntPtr arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate long Func_long___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_long(__IntPtr __instance, long arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_string8___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8_string8_string8___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr___IntPtr_uintPtr_uint(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, uint* arg3, uint arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr_longPtr___IntPtrPtr___IntPtrPtr(__IntPtr __instance, __IntPtr arg1, long* arg2, __IntPtr* arg3, __IntPtr* arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangParameterCategory_ulong_ulong_boolPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangParameterCategory arg1, ulong arg2, ulong arg3, bool* arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_uint___IntPtr(__IntPtr __instance, uint arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_long___IntPtr(__IntPtr __instance, long arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long_long___IntPtr___IntPtr(__IntPtr __instance, long arg1, long arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long_long___IntPtr(__IntPtr __instance, long arg1, long arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_long_long___IntPtr(__IntPtr __instance, long arg1, long arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_int_int___IntPtr___IntPtr(__IntPtr __instance, int arg1, int arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr___IntPtr_uint___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, uint arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_long___IntPtr___IntPtr(__IntPtr __instance, long arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_string8_ShaderSlang_Net_Bindings_Generated_SlangStage___IntPtr___IntPtr(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, global::ShaderSlang.Net.Bindings.Generated.SlangStage arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate global::ShaderSlang.Net.Bindings.SlangResult Func_ShaderSlang_Net_Bindings_SlangResult___IntPtr_ShaderSlang_Net_Bindings_Generated_SlangCompileTarget___IntPtr___IntPtr(__IntPtr __instance, global::ShaderSlang.Net.Bindings.Generated.SlangCompileTarget arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1);
    }
}
